[ { "title": "StackView 안쪽으로 margin? padding? 여백 주는 방법!", "url": "/posts/stackview-margin/", "categories": "iOS, Guide", "tags": "ios, guide, stackview, margin", "date": "2023-01-08 02:00:00 +0000", "snippet": "StackView는 AutoLayout을 보다 편하게 구성할 수 있도록 해주는 View라서 복잡한 Layout을 구현하기에 딱 좋은 것 같아요. 그런데 이번에 이 StackView의 안쪽으로 여백을 줘야할 일이 있어 찾아 정리해봤습니다!StoryBoard에서 여백주기스토리보드에서 주는 방법은 비교적 간단합니다.안쪽 여백은 없는 StackView좌우 16씩 여백을 주었고, StackView의 백그라운드 색상은 회색!그런데 View와 View 간격인 Spacing 부분외에는 안보이죠?바깥쪽은 16씩 간격을 띄웠지만, 안쪽에는 여백이 없다는 뜻이에요.이제 스택뷰를 선택하시고 오른쪽 인스펙터의 메뉴를 보면, Layout Margins라는 속성이 있습니다.이 버튼을 누르고 Language Directinal을 선택해주세요!안쪽 여백을 줄 수 있는 Language Directinal 속성그럼 인스펙터에서 상하좌우 여백값이 나타나고, StackView에 여백이 뙇! 생기는게 보이시죠?이 값을 조정해주시면 원하는 부분의 안쪽으로 여백을 줄 수 있습니다!상하좌우 여백이 설정된 StackView코드로 여백주기코드 역시 간단해요.설명에 앞서 먼저 코드부터 볼까요?stackView.layoutMargins = UIEdgeInsets(top: .zero, left: 16, bottom: .zero, right: 16)헉! 한 줄이라니!? 너무 간단하죠?근데 이 여백값들이 반영 되려면 한가지 속성을 설정해줘야 합니다.stackView.isLayoutMarginsRelativeArrangement = trueisLayoutMarginsRelativeArrangement 바로 이녀석인데요,Apple Document isLayoutMarginsRelativeArrangement설명애플 공식 문서에서 보면 안쪽 뷰들에 여백을 줄 것인지 결정하는 옵션인 것이죠.즉, 이 속성의 기본 값이 false이기 때문에 StackView의 안쪽에 배치된 뷰에 여백을 줄 수 없는 것입니다.결국 두 속성이 설정되어야 반영되는 것!stackView.layoutMargins = UIEdgeInsets(top: .zero, left: 16, bottom: .zero, right: 16)stackView.isLayoutMarginsRelativeArrangement = true메일보내기포스팅에 잘못된 부분이 있거나 궁금하신 점이 있다면, 왼쪽 사이드 하단 메뉴에서 로퍼즈팀으로 메일을 보내주세요!최대한 빠른 시간 내에 회신드릴게요! 감사합니다." }, { "title": "애플의 강력한 프로그래밍 언어, Swift의 특징", "url": "/posts/about-features-of-swift/", "categories": "Swift, 특징", "tags": "swift, 특징, 개념, 이론", "date": "2023-01-01 02:12:00 +0000", "snippet": "Swift는 애플에서 개방한 프로그래밍 언어죠? 애플의 모든 제품 앱을 만들 수 있는데요. 과연 어떤 특징들이 있는지 한번 살펴보겠습니다~!언어적 특징현대 프로그래밍 언어에서 Swift는 어떤 특장점이 있을까요? 안정성(nil-Safe)스위프트는 안전한 프로그래밍을 지향합니다.옵셔널과 빠른 탈출 구문들이 대표적인 예죠. guard let 문이나 if let 구문 같은 것들이요.그 외에도 오류처리, 강력한 타입 통제등은 개발자가 할 수 있는 사소한 오류들을 방지할 수 있도록 해줍니다. 신속성(Fast)거슬러 올라가면 Swift는 C언어에서 출발합니다. 그래서 나온 것이 Obejectiv-C인거 다 알고 계시죠?그리고 Objective-C를 업그레이드 한 것이 바로 Swift!Swift는 고성능 LLVM컴파일러로 C언어와 비슷한 성능이라고 하는데요, 그래서 실행속도가 빠르다고 합니다.애플피셜이지만, Objective-C 의 약 1.5배, Python의 220배 빠르다고.. 더 나은 표현성(Expressive)간결하고 가독성이 좋습니다. 파이썬의 문법을 많이 채용한 느낌적인 느낌이 드는 건 저 뿐일까요?Kotlin도 해보고 기타 몇몇 언어를 접해본 입장에서, Swift의 표현성은 썩 마음에 드는 편이에요.그리고 표현성이 좋다면 디버깅등에서 분명 장점이 있습니다. 다중 패러다임 프로그래밍 언어명령형, 객체지향, 함수형, 프로토콜 지향 프로그래밍 패러다임을 채택한 언어입니다.뭐.. 요즘 대부분의 프로그래밍 언어들은 다양한 프로그래밍 패러다임을 채택하고 있긴 합니다. C언어에서도 이제 객체지향으로 프로그래밍을 할 수 있잖아요?아무튼, 이 중 스위프트가 강조하는 것은 함수형, 프로토콜 지향 패러다임입니다. 현대 프로그래밍 언어의 주요 기능들.클로저, 다중 리턴 타입, 네임스페이스, 제네릭, 타입 추론등 역시 Swift에서도 지원합니다. ARC(Auto Reference Counting)자바에 가비지 컬랙션(Garbage Collection)이 있다면, Swift에는 ARC라는 기능이 있습니다.역할은 비슷해요. 메모리 관리를 자동으로 해주는 녀석인 것이죠.그래서 개발자는 그저 객체를 만들기만 하면 됩니다. 만약 객체가 어디에서도 참조되지 않는다면 자동으로 메모리에서 해제해줄테니까요. 함수형 패러다임과 프로토콜위에서 Swift는 여러 프로그래밍 패러다임중에 함수형을 강조하고 프로토콜 방식을 지향한다고 했는데요.함수형RxSwift, Combine 등을 보면 알 수 있듯이 애플에서 강조하는 패러다임입니다.Array, Dictonay등에서도 흔하게 볼 수 있죠. filter, map, reduce 함수들도 따지고보면 함수형 프로그래밍입니다.이는 대규모 병렬처리를 쉽게 할 수 있다는 특징과, 변수의 상태변화에 따른 처리가 아닌, 함수만으로 응용할 수 있는 것을 더 강조했다고 보시면 됩니다.또한 가장 큰 특징은 함수를 일급객체로 다룬다는 것(함수를 호출, 전달, 반환할 수 있다는 뜻)이에요.장점 어떤 상황에서 프로그램을 실행하더라도 일정한 결과를 도출할 수 있다. 값 변화를 멀리하므로 함수 호출이 각각 상호간에 배타적아로 실행되고 병렬처리에 유리하다. 대규모 병렬처리, 멀티 코어의 환경에서 효율적인 프로그램이이 가능하다.프로토콜 지향2015년, 2.0버전이 발표되면서 Swift에는 프로토콜, 익스텐션이 추가 되었고, 프로토콜 지향 프로그래밍이 가능해졌습니다.덕분에 개발자는 참조 문제에서 조금 더 자유로워질 수 있고, 다중상속이 불가능한 한계를 뛰어넘었으며 더 나은 추상화 매커니즘의 구현이 가능해졌다는 의미입니다.대표적으로 대부분의 타입이 class에서 상속이 불가능한 struct로 바뀌었다는 점이 있겠네요.그러면서도 공통 기능을 가질 수 있게 하는 방법이 바로 프로토콜과 익스텐션입니다.메일보내기포스팅에 잘못된 부분이 있거나 궁금하신 점이 있다면, 왼쪽 사이드 하단 메뉴에서 로퍼즈팀으로 메일을 보내주세요!최대한 빠른 시간 내에 회신드릴게요! 감사합니다." }, { "title": "어려운 RxSwift! Observable 함수 정리", "url": "/posts/rxswift-methods/", "categories": "RxSwift, Methods", "tags": "swift, grammer, rxswift, methods", "date": "2022-12-28 05:56:00 +0000", "snippet": "Observer 선언Observable은 선언만 해서는 동작하지 않는다. 말 그대로 ‘관측가능한’ 상태이기 때문이다.반드시 구독(subscribe)을 해야만 작동한다. 아무도 보지 않는데 동작할 이유가 없다.Just단 1개의 요소만 방출하는 함수다.Observable&lt;Int&gt;.just(1)Of1개 이상의 요소들을 방출하는 함수다.쉼표로 구분해서 나열하거나 배열을 방출할 수도 있다.//여러개의 요소를 방출하는 Obsevable SequenceObservable&lt;Int&gt;.of(1, 2, 3, 4, 5)//1//2//3//4//5//배열을 방출하며 이때 타입은 &lt;Array&gt;가 된다.//1개의 배열을 방출한다는 점에서 just와 같은 기능을 한다.Observable.of([1, 2, 3, 4, 5])//[1, 2, 3, 4, 5]fromArray형태만 인자로 받아 각 요소를 방출한다.Observable.from([1, 2, 3, 4, 5])//1//2//3//4//5Subscribe 사용법가장 처음에도 언급했지만 Observable은 그냥 ‘관측이 가능한’ 상태이기 때문에 Observer로 관측을 하거나, subscribe해야만 작동한다.//onNext를 명시하는 가장 일반적인 사용법이다.Observable.of(1, 2, 3) .subscribe(onNext: { print($0) })//1//2//3//onNext를 명시하지않고 간략하게 표현할 수도 있다.//이때는 onNext이벤트 및 onCompleted이벤트까지 출력된다.Observable.of(1, 2, 3) .subscribe { print($0) }//next(1)//next(2)//next(3)//completed//Observable에 요소가 있는지 확인 할 수 있다.Observable.of(1, 2, 3) .subscribe { if let element = $0.element { print(element) } }//1//2//3Observable 구독 취소‘관측 가능한 상태’인 Observable을 구독했다면, 반대로 취소도 가능해야 한다.subscribe의 Return형태가 바로 Disposable인 이유가 여기에 있다. 그래서 이 return에 대한 처리가 바로 dispose()이다.이때, 각각의 Observable에 대한 메모리 할당을 해제할 수도 있지만, DisposeBag으로 일괄적으로 처리할 수도 있다.//방출 후 dispose로 Observable을 종료한다.Observable.of(1, 2, 3) .subscribe(onNext: { print($0) }) .dispose() //명시적으로 이 subscribe를 종료, 메모리 해제하는 것이다.//disposeBag 객체로 모아서 할당된 메모리를 헤제한다.let disposeBag = DisposeBag()Observable.of(1, 2, 3) .subscribe(onNext: { print($0) }) .disposed(by: disposeBag) //disposeBag에 넣어두고, DisposeBag객체가 해제될 때Dispose()와 DisposeBag()subscribe의 return type은 disposable이기 때문에 subscribe의 끝에는 dispose()를 해주어야 한다.말 그대로 구독을 종료하는 것이다.그리고 dispose() 함수를 쓰면 그 즉시 구독이 해제된다. 더이상 구독이 불가능한 상태가 되는 것이다. 그럼 구독한 이유가??반면, DisposeBag() 객체가 메모리에서 해제될 때까지 구독을 유지하게 된다.다시 말하면, 구독이 필요없어지는 순간이 바로 DisposeBag 객체가 메모리에서 해제되는 순간이란 의미이다.따라서 dispose()로 구독을 바로 종료하는 경우는 거의 없다.어떤 요소도 방출하지 않는 함수empty요소가 없는 Sequence를 방출한다.언제 쓸 수 있을까? 의도적으로 0개의 값을 가진 Observable을 Return하고 싶을 때 즉시 종료되는 Observable을 Return하고 싶을 때//Count가 0인 Obsevable이며 onCompleted 외에는 어떠한 값도 방출하지 않는다.Observable.empty() .subscribe { print($0) }//Type을 지정해주면 이벤트를 출력한다.Observable&lt;Void&gt;.empty() .subscribe { print($0) }//completed//위와 예시와 같은 결과를 출력한다.Observable&lt;Void&gt;.empty() .subscribe(onNext: { }, onCompleted : { print(\"completed\") })//completedneverempty가 count 0인 Observable을 방출하고 정상적으로 종료된다면, never는 어떠한 Sequence도 방출하지 않고 종료도 안되는 함수다.언제 쓰지..?Observable&lt;Void&gt;.never() .debug(\"never\") //굳이 확인하고 싶을 때 .debug()를 사용해서 작동하는 것을 확인할 수는 있다. .subscribe(onNext: { print($0) }, onCompleted: { print(\"completed\") })CreateObservable이 직접 Sequence를 만드는 함수다.//값을 방출하는 Sequence를 직접 만든다.//Disposable을 반환하는 Observable을 방출, subscribe가 출력한다.Observable.create { observer -&gt; Disposable in observer.onNext(1) observer.onNext(2) return Disposables.create()}.subscribe { print($0)}.disposed(by: disposeBag)//next(1)//next(2)//만들어진 Sequence에 Error를 일으킬 수 있다.//Completed되기 전에 에러가 있으면 그 즉시 종료된다.enum Error: Error { case anError}Observable&lt;Int&gt;.create { observer -&gt; Disposable in observer.onNext(1) observer.onError(Error.anError) observer.onCompleted() observer.onNext(2) return Disposables.create()}.subscribe( onNext: { print($0) }, onError: { print($0.localizedDescription) }, onCompleted: { print(\"completed\") }, onDisposed: { print(\"disposed\") }).disposed(by: disposeBag)//1//The operation couldn’t be completed. (__lldb_expr_42.Error error 0.)//disposed메일보내기포스팅에 잘못된 부분이 있거나 궁금하신 점이 있다면, 왼쪽 사이드 하단 메뉴에서 로퍼즈팀으로 메일을 보내주세요!최대한 빠른 시간 내에 회신드릴게요! 감사합니다." }, { "title": "iOS에서 쓰는 Swift 클로저! 톺아보기 1편", "url": "/posts/understanding-closure1/", "categories": "Swift, Grammer", "tags": "swift, grammer", "date": "2022-12-23 06:23:00 +0000", "snippet": "먼저 Swift는 굉장히 현대적인 프로그래밍 언어입니다.그래서 클로저, 타입추론, 옵셔널등 현대 프로그래밍 언어의 주요기능들을 대부분 채택했는데요.이 중에서 클로저에 대해 알아볼까 합니다.클로저는 다른 언어에서 람다식, 고차함수등으로 불리기도 하는데, 개념도, 사용법도 거~의 흡사합니다.특장점도 비슷하죠. 클로저는 코드를 더 간결하게 만들 수 있어요. 클로저는 함수형 프로그래밍이라서 외부 요인으로 인한 오류를 최소화할 수 있어요. 이로인해 클로저는 병렬처리에 유용합니다.클로저의 기본 형태는 다음과 같습니다.{ (parameters) -&gt; return type in //TODO}Swift에서 클로저는 다른 말로 익명함수라고도 합니다. 하지만 함수라는 사실은 변함이 없어요.그래서 함수로써 가져야할 파라미터가 있고, 리턴값이 있습니다.그런데, 어딘가 iOS앱을 만들면서 써왔던 filter, map등의 함수와 비슷하지 않나요?네, 맞습니다. 이것들이 바로 클로저에요!let scores = [30, 80, 10, 50, 100]let under50 = scores.filter { score -&gt; Bool in //scores라는 배열의 각 요소를 score라는 이름의 파라미터 이름으로 정의, //Filter의 Return type은 Bool return score &lt; 50}//under50 : [30, 10] parameters는 생략할 수 있어요. 생략된 parameter는 $0, $1, $2… 등으로 나타낼 수 있어요.그래서 이렇게도 축약할 수 있습니다.let scores = [30, 80, 10, 50, 100]let under50 = scores.filter { return $0 &lt; 50 }//under50 : [30, 10]일급객체Swift는 클로저는 일급객체로 다뤄지는 데요,이것이 무슨 말이냐, 함수를 인자로 보내거나, 함수를 전달하거나, 함수로 반환할 수 있다는 것입니다. 함수를 변수나 상수에 대입해서 사용할 수 있어요.let printName = { (name: String) in \"안녕하세요, \\(name)님\"}let greeting: String = printName(\"Loperz\")print(greeting)//안녕하세요, Loperz님 return type과 retrun키워드도 생략할 수 있어요.클로저의 parameter는 오직 parameter Name으로만 사용됩니다. 클로저를 함수의 인자로 사용할 수도 있습니다.let add = { (a:Int, b:Int) -&gt; Int in return a + b}func sum(n1: Int, n2: Int, function: (Int, Int) -&gt; Int) -&gt; Int { return function(n1, n2)}sum(n1: 2, n2: 3, function: add) //마지막 인자가 클로저면 생략 가능!//5 복잡해보일 수 있는 구문이지만, parameter Name과 인자를 구분하면 눈에 들어올거에요!그리고 위 구문처럼 함수의 마지막 인자가 클로저라면 이렇게 생략할 수도 있습니다.et add = { (a:Int, b:Int) -&gt; Int in return a + b}func sum(n1: Int, n2: Int, function: (Int, Int) -&gt; Int) -&gt; Int { return function(n1, n2)}//마지막 인자인 클로저를 생략하고 바로 { } 로 표현할 수 있어요//이를 후행 클로자라고 합니다!sum(n1: 2, n2: 3) { $0 + $1}//5 클로저를 반환 타입으로 하는 함수를 만들 수 있어요.func greeting2(msg: String) -&gt; (String, String) -&gt; String { return { greeting, name in return name + \"님, \" + greeting + \". \" + msg }}let closure = greeting2(msg: \"화이팅입니다!\")closure(\"안녕하세요\", \"Loperz\") greeting2(msg: String) 이 (String, String) -&gt; String 형태의 클로저를 반환합니다.마지막 클로저를 반환하는 구문은 상당히 복잡하죠?하지만 하나씩 살펴보면 충분히 이해하실 수 있을 거에요!먼저 greeting2(msg: String) -&gt; 여기까지 보면 일반적인 함수 입니다.그리고 반환값이 바로 (String, String) -&gt; String 형태의 클로저인 것이죠.때문에 클로저를 return하는 것을 알 수 있어요.{ greeting, name in return name + \"님, \" + greeting + \". \" + msg}따로 떼어놓고 보니 딱 클로저의 기본 형태죠?greeting2(msg: )는 이 클로저를 return하게 됩니다.클로저의 개념과 기본 형태, 그리고 약간의 경량 문법도 같이 살펴봤는데요,현대 프로그래밍 언어인 만큼 코드는 간결해지지만 조금 주의깊게 봐야하는 부분이었습니다!하지만 하나씩 분해해보니 크게 어렵게 느껴지진 않으셨을 것 같아요.클로저만 잘 익혀두시면 앞으로 공부하게 될 RxSwift나 SwiftUi에 큰 도움이 됩니다!다음엔 클로저를 더 쉽고, 간략하게 쓸 수 있는 방법을 포스팅해볼게요, 그게 언제가 될지는 모르겠지만요?ㅎㅎ메일보내기포스팅에 잘못된 부분이 있거나 궁금하신 점이 있다면, 왼쪽 사이드 하단 메뉴에서 로퍼즈팀으로 메일을 보내주세요!최대한 빠른 시간 내에 회신드릴게요! 감사합니다." }, { "title": "프로그램이 사용하는 메모리 영역 Code, Data, Stack, Heap", "url": "/posts/about-memory-area/", "categories": "프로그래밍, 개념", "tags": "프로그래밍, 개념, 컴퓨터 기초", "date": "2022-12-17 08:51:00 +0000", "snippet": "프로그램은 컴퓨터의 어디에 저장될까요? 정답은 하드디스크!그렇다면 프로그램은 어디서 실행될까요? 바로 메모리입니다.일단 하드디스크에서 프로그램 정보를 읽어 메모리에 로드되는 것이죠.이때 운영체제는 프로그램에 메모리를 할당해주는데, 클래스에 할당할 공간, 변수에 할당할 공간, 함수에 할당할 공간등이 정해집니다. 그 공간들이 바로 Code, Data, Stack, Heap 영역인 것입니다.각 영역들을 살펴볼게요!Code이른바 텍스트 영역이라고 해서 개발자가 작성한 소스코드가 저장되는 공간입니다.명령문이 저장되는 공간이라고 생각하시면 편할 것 같은데요, 함수, 상수, 제어문등이 이에 속합니다.Data전역/정적 변수들이 저장되는 공간이라고 볼 수 있습니다. 한번 선언되면 프로그램이 종료될 때까지 남아있는, 말 그대로 ‘데이터’를 저장하는 영익인셈이죠.데이터 영역은 프로그램의 시작과 함께 할당되고 종료시 해제됩니다.Stack선입선출(LIFO, Last In, First Out)의 방식으로 많이 알려져 있는 이 Stack영역은 지역/매개변수가 저장되는 공간입니다. 함수가 호출될 때 할당되며 함수가 종료되면 해제되죠. 또한 각 함수마다 공간을 할당받게 되기 때문에 다른 함수의 변수에 대한 존재여부를 알지 못하는 이유가 여기에 있습니다.Heap개발자가 직접 메모리를 할당했을 때 저장되는 영역입니다.그러니까 개발자가 직접 관리할 수 있는 메모리 영역인 것이죠. 이를테면 C언어등에서는 malloc등으로 동적으로 메모리를 할당할 수 있습니다. 그리고 개발자가 직접 그 메모리를 해제해야만 합니다. 이렇게 관리할 수 있는 공간인데, iOS앱의 경우 즉, Swift는 ARC(Automatic Reference Counting)라는 메모리 관리 모델이 있어 특별히 신경쓸 필요가 없는 부분입니다. 하지만 내부적으로는 Class, Struct등 객체를 생성하거나 소멸할 때 Heap영역에 저장된 다는 것!Heap과 Stack은 같은 메모리를 공유하면서 각 공간을 침범하면 Overflow가 발생한다메일보내기포스팅에 잘못된 부분이 있거나 궁금하신 점이 있다면, 왼쪽 사이드 하단 메뉴에서 로퍼즈팀으로 메일을 보내주세요!최대한 빠른 시간 내에 회신드릴게요! 감사합니다." }, { "title": "Swift 이것만 잘써도 프로! Filter, Map, Reduce에 확실하게 잡기", "url": "/posts/filter-map-reduce/", "categories": "Swift, Grammer", "tags": "swift, grammer, filter, map, reduce", "date": "2022-12-17 06:19:00 +0000", "snippet": "이른바 컬렉션이라 부르는, Array와 Dictionary는 각 요소를 쉽게 골라내거나(filter), 변환하거나(map), 합치는(reduce) 클로저를 지원하고 있어요! 물론 이 외에도 forEach, compactMap 등이 있긴 한데, 이 세가지만 잘 써도 만들고자 하는 앱은 충~분히 다 만들 수 있고 가장 대표적이기도 합니다. 무엇보다 적재적소에서 잘 쓰면 데이터를 가공하는 일은 식은 죽 먹기!FilterReturns an array containing, in order, the elements of the sequence that satisfy the given predicate.주어진 조건을 만족하는 값들을 새로운 컨테이너로 반환합니다.애플 개발 문서에도 정의하고 있는데요, 말 그대로 많은 데이터 중에 조건 맞는 데이터를 골라내서 새로운 컨테이너로 Return하는 역할을 합니다.애플에서 제공하는 예시를 볼까요?let cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]let shortNames = cast.filter { $0.count &lt; 5 }print(shortNames)// Prints \"[\"Kim\", \"Karl\"]\"별다른 설명이 필요없을 정도로 이해가 쉬운 예시인 것 같죠? 각각의 이름 길이가 5글자보다 작은 이름만을 골라서 새로운 배열로 반환한 것을 알 수 있습니다.MapReturns an array containing the results of mapping the given closure over the sequence’s elements.기존의 값들을 주어진 조건으로 할당(mapping)해서 새로운 결과 컨테이너틀 반환합니다.이번엔 각 요소를 이용해서 기존의 값들을 변환, 새로운 형태의 컨테이너로 Return하는 클로저입니다.한번에 와닿지 않을 수도 있습니다, 하지만! 막상 써보면 그렇게 어렵지 않아요.애플에서 제공하는 예시를 한번 볼까요?let cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]let lowercaseNames = cast.map { $0.lowercased() }// 'lowercaseNames' == [\"vivien\", \"marlon\", \"kim\", \"karl\"]let letterCounts = cast.map { $0.count }// 'letterCounts' == [6, 6, 3, 4]역시 특별한 설명이 필요없을 정도로 직관적이죠?첫 번째 예시는 모두 소문자로 변환한 배열을 Return하는 구문입니다.소문자로 바꾼 것 뿐이니 lowercaseNames는 역시 String 타입의 배열입니다.두 번째 예시는 각 이름의 길이를 반환하는 군요.그럼 lotterCounts의 타입은 어떨까요?$0.count는 Int형이니 letterCounts 배열의 타입이 Int로 바뀐 것이 보이네요!조금 헷갈릴 수 있는 부분이니 조금만 더 살펴볼까요?만약 두 번째 예시를 for-in 구문으로 만들었다면 아래와 같이 만들 수 있습니다.var letterCounts:[Int] = []cast.forEach { str in let strCount = str.count letterCounts.append(strCount)}// `letterCounts` == [6, 6, 3, 4]흠 역시 고차함수 map을 이용한게 직관성이 더 높아보이죠?그런데 컴파일러의 최적화 성능도 고차함수를 이용하는 것이 더 좋다고 합니다!ReduceReturns the result of combining the elements of the sequence using the given closure.주어진 조건을 이용해서 기존의 값들을 결합한 새로운 컨테이너를 반환합니다.마지막으로 배열의 모든 요소들을 더하기, 빼기, 곱하기, 나누기등 특별한 연산으로 결합해서 새로운 컨테이너를 Return하는 클로저입니다.그런데 filter, map과는 다르게 2가지 파라미터가 필요해요. initialResult: Result 초기값, 클로저가 실행될 때 nextPartialResult로 전달합니다. nextPartialResult: (Result, Self.Element) throws -&gt; Result 연산된 결과가 누적되는 파라미터 입니다. 클로저이므로 결과를 누적했다가 반환하게 됩니다. Reduce 예시 입니다.let numbers = [1, 2, 3, 4]let numberSum = numbers.reduce(0, { x, y in x + y})// numberSum == 10이 코드를 조금 설명하자면, initialResult의 값으로 0을 줬네요.그리고 x, y는 각 $0과 $1입니다. 즉, initialResult 값을 초기값으로 0을 전달하면서 numbers배열의 각 요소를 더하는(x + y) 결과를 Return하는 것입니다.위 예시는 이렇게도 표현 가능합니다.//클로저의 인자를 제거하고 $0, $1로 대체 가능let numberSum2 = numbers.reduce(0) { $0 + $1}//nextPartialResult 파라미터를 연산자로 대체 가능let numberSum3 = numbers.reduce(0, +)결론결과적으로 보면 filter, map, reduce는 for-in문 또는 forEach문으로 대체가 가능한 함수들입니다. 그런데 map에서도 다뤄봤지만 코드가 아주 간결해짐을 알 수 있었습니다. 더군다나 컴파일러의 최적화 성능 또한 더 좋아진다고 하니 안쓸 수가 없겠죠?? Array와 Dictionary를 다룬다면 잊지 마세요~!이 세가지 고차함수를 알고 적재적소에서 잘 써먹는다면 능히 데이터를 다루는 일에 있어서는 자부심을 가져도 좋을 것 같습니다!메일보내기포스팅에 잘못된 부분이 있거나 궁금하신 점이 있다면, 왼쪽 사이드 하단 메뉴에서 로퍼즈팀으로 메일을 보내주세요!최대한 빠른 시간 내에 회신드릴게요! 감사합니다." }, { "title": "iOS앱 오토레이아웃 스냅킷 Inset, OffSet 이때 쓰세요.", "url": "/posts/difference-inset-offset/", "categories": "iOS, Guide", "tags": "ios, guide, autolayout, inset, offset", "date": "2022-12-09 07:16:00 +0000", "snippet": "모든 레이아웃을 스토리보드로 잡을 수 있다면 참 좋겠지만 코드로 뷰를 만들고 레이아웃을 잡아줘야하는 경우가 있습니다. 이때 유용한 라이브러리가 바로 SnapKit인데요, 쓰면서도 헷갈리는 inset과 offset!! 둘 다 간격을 띄우는 옵션이고 별차이가 없는 것 같은데.. 무슨 차이가 있는 걸까요? 한번 정리해봤습니다!실험시작먼저 레이아웃 샘플을 하나 볼까요?SnapKit 예시큰 backView안에 작은 blueView를 넣은 모습인데요, top, trailing, bottom, leading 모두 30정도씩 간격을 띄운 예시입니다. offset과 inset으로 어떻게 이 레이아웃을 만들 수 있는지, 어떤 차이가 있는지 살펴볼게요!먼저 offset을 이용한 코드입니다.//offset을 이용한 간격 띄우기blueView.snp.makeConstraints { $0.leading.equalToSuperview().offset(30) $0.top.equalToSuperview().offset(30) $0.trailing.equalToSuperview().offset(-30) $0.bottom.equalToSuperview().offset(-30)}이번엔 inset을 이용한 코드입니다.//inset을 이용한 간격 띄우기blueView.snp.makeConstraints { $0.edges.equalToSuperview().inset(30)}두 코드 모두 위 샘플의 레이아웃을 구성할 수 있습니다.offset은 각 방향을 하나씩 설정했구요, inset은 한 줄로 4방향을 일괄적으로 처리했습니다.뭔가 갸웃하게 되죠? 똑같은 역할이고 왠지 inset이 더 나아보이는데.. 왜 offset과 inset을 나눠놓은 걸까요? 하나씩 살펴보겠습니다.offset으로도 한 줄로 간결하게 처리해보겠습니다.//offset을 이용해 4방향 간격 띄우기blueView.snp.makeConstraints { $0.edges.equalToSuperview().offset(30)}offset으로 일괄 4방향 간격띄우기 결과앗! trailing과 bottom이 backView를 벗어났네요. 흐음.. 왜 슈퍼뷰를 벗어났을까요?다시 이 코드를 보면 왜 trailing과 bottom에 마이너스(-)값을 줘야했는지 이해가 되실 것 같은데요,//offset으로 4방향 간격 띄우기blueView.snp.makeConstraints { $0.leading.equalToSuperview().offset(30) $0.top.equalToSuperview().offset(30) $0.trailing.equalToSuperview().offset(-30) $0.bottom.equalToSuperview().offset(-30)}좌상단을 기준으로 blueView의 constraint = backView(슈퍼뷰)의 constraint + offset 값 공식이 적용되기 때문입니다. top의 간격 : 슈퍼뷰의 top + offset(30) trailing의 간격 : 슈퍼뷰의 trailing - offset(30) bottom의 간격 : 슈퍼뷰의 bottom - offset(30) leading의 간격 : 슈퍼뷰의 leading + offset(30)좌상단을 기준으로 offset이 적용되는 예시이번엔 inset으로 4방향을 개별적으로 띄워볼까요?//inset으로 4방향 간격 띄우기blueView.snp.makeConstraints { $0.leading.equalToSuperview().inset(30) $0.top.equalToSuperview().inset(30) $0.trailing.equalToSuperview().inset(-30) $0.bottom.equalToSuperview().inset(-30)}inset으로 각 방향 간격 띄우기 결과어라?? 마이너스(-)값을 준 trailing과 bottom이 슈퍼뷰를 벗어났네요! inset은 offset의 공식과는 다른 것 같습니다.반대로 leading과 top에 마이너스(-)값을 적용해보겠습니다.blueView.snp.makeConstraints { $0.leading.equalToSuperview().inset(-30) $0.top.equalToSuperview().inset(-30) $0.trailing.equalToSuperview().inset(30) $0.bottom.equalToSuperview().inset(30)}inset으로 각 방향 간격 띄우기 결과2아하, 뭔가 감히 잡히시나요?만약 샘플과 같은 레이아웃을 각 방향에 inset으로 간격을 띄우고 싶다면 모든 방향에 플러스(+)를 줘야하겠군요.이는 즉, offset은 좌상단을 기준으로 간격을 띄웠다면, inset은 절대값으로 간격을 띄운다는 것을 알 수 있습니다.결론offset각 방향에 대해 개별적으로 간격을 띄우고 싶을 때 사용하면 적합합니다.inset최소 둘 이상의 방향에 대해 간격을 띄우고 싶을 때 사용하면 적합합니다.참고로 inset도 아래와 같이 각 방향에 대해 개별적으로 간격을 띄울 수 있습니다.blueView.snp.makeConstraints { $0.edges.equalToSuperview().inset(UIEdgeInsets(top: 30, left: 30, bottom: 30, right: 30))// $0.edges.equalTo(UIEdgeInsets(top: 30, left: 30, bottom: 30, right: 30)) 위 코드와 동일}메일보내기포스팅에 잘못된 부분이 있거나 궁금하신 점이 있다면, 왼쪽 사이드 하단 메뉴에서 로퍼즈팀으로 메일을 보내주세요!최대한 빠른 시간 내에 회신드릴게요! 감사합니다." }, { "title": "필요한 Git 명령어 정리", "url": "/posts/about-git-command/", "categories": "Git, Command", "tags": "git, command", "date": "2022-12-04 09:18:00 +0000", "snippet": "로컬 저장소에서 사용할 수 있는 명령어들스테이징(git add 명령어로 업로드된 위치)과 커밋을 한번에 할 수 있다.단, 한번이라도 커밋한 파일에 대해서만 가능하다.&gt; git commit -am “message”커밋 기록 자세히 볼 수 있으며, 추가 옵션으로 다양한 형태로 볼 수 있다.&gt; git log&gt; git log —oneline (한줄로 보기)&gt; git log —oneline —branches (브랜치별로 기록 보기)&gt; git log —oneline —branches —graph (그래프로 기록 보기)&gt; git log —oneline —all —graph(모든 브랜치 그래프로 확인)현재 작업중인 파일과 git에 있는 최신버전의 파일이 어떻게 다른지 확인할 수 있다.&gt; git diff커밋과 관련된 파일까지 함께 보는 방법이다.&gt; git log --state바로 직전 커밋한 메세지를 수정할 수 있다.vim 에디터가 뜨면 원래 메세지가 상단에 나타나고 이를 수정, 저장한 후 종료하면 메세지가 수정되고 이전 커밋에 더해진다.단, 가장 마지막 커밋에 대해서만 가능하다.&gt; git commit --amend작업 트리에서 수정한 내용을 취소할 수 있다.&gt; git restore &lt;파일명&gt;git add로 업로드한 상태 즉, 스테이징 상태에서 add하기 전으로 되돌린다.&gt; git restore —staged &lt;파일명&gt;git commit으로 올라간 최신 커밋을 되돌린다.&gt; git reset HEAD^git log등을 통해 커밋 해시를 확인하고 특정 커밋으로 되돌린다.&gt; git reset —hard &lt;복사한 커밋 해시&gt;이때, 커밋을 취소하더라도 기록은 남겨둘 수 있는 방법이다.&gt; git revert &lt;복사한 커밋 해시&gt;Github와 Local 저장소를 연결하기원격 저장소와 연결한다.&gt; git remote add origin &lt;저장소 주소&gt;연결 상태를 확인한다.&gt; git remote -v서로 다른 컴퓨터와 협업하기프로젝트의 HTTPS 주소를 복사 후 터미널에서 git clone명령어로 특정 디렉토리로 코드를 가져온다.&gt; git clone &lt;원격 repositofy URL&gt; &lt;복사할 directory&gt;처음으로 push할때는 -u 옵션을 붙여 해당 브랜치로 push할 것을 알린다. 최초 1번만 수행하면 된다.&gt; git push -u origin &lt;브랜치명&gt;빠른 병합등으로 코드를 병합하기 전에 원격 브랜치 정보 가져온다.실제로 git log, git status등으로 확인해도 파일은 확인할 수 없다.&gt; git fetch이 명령어는 현재 로컬 저장소에 커밋된 파일과 원격 저장소의 파일과의 차이점을 확인할 수 있다.&gt; git diff HEAD origin/main확인 후, 병합한다.&gt; git merge origin/main그 외Markdown 문법링크 거는 방법이다.“부가 설명”은 마우스 오버시 나타난다.&lt;주소&gt;[대체할 text](주소)[대체할 text](주소, “부가 설명”)이미지를 Github에 올리는 방법이다.[Github] -&gt; [addfiles] -&gt; [이미지 업로드]현재 위치를 기준으로 한다.![이미지](./&lt;이미지 파일명&gt;)" }, { "title": "Xcode에 파일 추가하는 2가지 방법", "url": "/posts/how-to-add-files-in-xcode/", "categories": "iOS, Guide", "tags": "ios, guide, modal, present, style", "date": "2022-11-29 13:41:00 +0000", "snippet": "단순히 디렉토리로 파일을 옮기는 것만으로도 바로 표시되고 쓸 수 있도록 하는 IDE가 많습니다, 하지만! 우리의 Xcode에서는 다른 방법으로 파일을 XCode에 넣어줘야 합니다. 저 역시 아주 가끔 디렉토리에만 파일을 넣어놓고 왜 Xcode에는 안나타날까 Build를 몇번씩 하곤 합니다. 이 정도는 만들어 줘도 되는거 아니니 애플아…ㅠ그래서 준비했습니다, 코드 및 이미지 파일등 XCode로 옮기는 방법!드래그 앤 드랍iOS앱을 만들어오셨던 분이라면 아주 익숙한 방법인데요, 바로 파일을 XCode로 드래그 앤 드랍하는 것입니다. 이미지 파일을 보통 이렇게 추가하곤 하죠. 코드 소스 파일도 동일하게 옮길 수 있어요.드래그 앤 드랍으로 파일을 Xcode로 가져오는 방법XCode메뉴 이용하기Xcode의 상단의 메뉴바에서 file - add files to \"앱이름\"으로 파일을 가져올 수 있어요.XCode메뉴를 이용해서 파일을 가져오는 방법두 번째는 Xcode의 메뉴를 이용한 방법인데요, 결과적으로는 드래그 앤 드랍과 동일합니다.하지만 전 이 방법을 더 자주 쓰는 것 같아요. 왜냐하면 온전히 Xcode내에서만 작업할 수 있어서 흐름이 유지되는 느낌적인 느낌일까요? 하나 더, 단축키를 이용해서 빠르게 파일을 추가할 수 있어요. 디렉토리 열고, 파일 찾는 것보다 조금 더 빠르죠.단축키 : 옵션(⌥) + 커맨드(⌘) + a알아두면 좋아요. Destination을 체크하지 않으면 파일을 지웠을 때 Xcode에서도 해당 파일을 찾을 수 없게되니 반드시 체크해주세요. 파일을 옮긴 후에는 Build 한번 해주시면 좋아요. 왜냐하면 Xcode가 해당 파일의 존재를 알게되어 코드에서 바로 쓸 수 있거든요.메일보내기포스팅에 잘못된 부분이 있거나 궁금하신 점이 있다면, 왼쪽 사이드 하단 메뉴에서 로퍼즈팀으로 메일을 보내주세요!최대한 빠른 시간 내에 회신드릴게요! 감사합니다." }, { "title": "iOS앱에서 Swift is/as 타입캐스팅 이렇게 쓸 수 있다.", "url": "/posts/understanding-is-and-as/", "categories": "Swift, Grammer", "tags": "swift, grammer, is, as, operator", "date": "2022-11-26 07:57:00 +0000", "snippet": "먼저 Is/As를 뜻하는 타입 캐스팅 용어의 뜻을 한번 풀어볼까요?영어로 된 용어는 뜻만 알아도 이놈이 어떤 일을 하는지 대충 알 수 있거든요.Type : 많이 익숙한 단어죠? 유형, 종류의 뜻을 가지고 있습니다.Casting : cast + ing의 형태로 배역을 맡는 것 정도로 생각하시면 좋겠네요.두 단어를 합쳐보면 아 대충 어떤 유형(객체, 데이터형등)에 배역을 맡기는 것이구나하고 짐작할 수 있죠.이 역할을 하는 것이 바로 As연산자입니다.그리고 Swift에는 배역을 맡기는 것뿐만 아니라 배역을 확인하는 것또한 가능해요.이것이 Is연산자입니다.대충 어떤 역할을 하는지 느낌이 오시나요?Is 사용법 in iOS앱Is연산자는 위에서 언급했듯이 ‘배역을 확인하는 역할’입니다. 여기서 말하는 배역이란 바로 타입입니다. String, Int, Instance등의 타입이죠.Is연산자는 맞는지 틀리는지만을 Return합니다.그래서 사실 타입 확인이 필요한 부분, iOS 코드 어디에서든 사용할 수 있습니다.AnyObject에 대한 확인이 가능하고요.let isNumber = 123if isNumber is Int { print(\"숫자입니다.\")}//숫자입니다.let isString = \"Loperz\"if isString is String { print(\"문자열입니다.\")}//문자열입니다.객체 확인으로도 사용할 수 있습니다.class Instrument { }class Weapon { }class Guitar: Instrument { }class Piano: Instrument { }let guitar = Guitar()let piano = Piano()guitar is Instrument //trueguitar is Weapon //falsepiano is Instrument //trueAs 사용법 in iOS앱As연산자에 대해서는 이미 많이 써 보셨을 것 같아요, 테이블뷰 또는 컬렉션뷰에서 셀을 가져올 때 혹은 화면전환하기 위해 뷰컨트롤러를 찾을 때 말이지요. 그래도 다시한번 볼까요?//CollectionView에서 Cell을 찾아 가져올 때func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -&gt; UICollectionViewCell { //사진을 보여줄 Cell guard let cell = collectionView.dequeueReusableCell( withReuseIdentifier: Keys.CellIds.albumListCell, for: indexPath ) as? AlbumCell else { return UICollectionViewCell() } //cell을 AlbumCell로 쓸 수 있는지 guard let을 통해 확인합니다. return cell}위 코드처럼 컬렉션뷰등에서 셀을 가져올 때 많이 볼 수 있습니다. as가 쓰인 문장을 말로 풀어본다면, cell을 AlbumCell타입의 cell로 쓸 것인지 확인합니다. 이때는 as에 널 세이프 연산자인 ?(물음표)를 붙여 만약 아니라면 UICollectionViewCell()을 Retrun하고 종료되겠네요.이번엔 Segue를 통한 화면전환시 as를 사용한 코드를 볼까요?//화면전환 할때if segue.identifier == \"DetailVC\" { let vc = segue.destination as! DetailVC //vc는 DetailVC타입의 segue의 목적지인 ViewController가 됩니다. vc.setImageToView(asset: imgAsset)}여기서 as에 !(느낌표)를 붙여 vc가 DetailVC타입의 ViewController임을 보장하는 코드입니다.메일보내기포스팅에 잘못된 부분이 있거나 궁금하신 점이 있다면, 왼쪽 사이드 하단 메뉴에서 로퍼즈팀으로 메일을 보내주세요!최대한 빠른 시간 내에 회신드릴게요! 감사합니다." }, { "title": "iOS 목업 데이터? plist로 만들어 쉽고 편리하게 사용하기", "url": "/posts/how-to-parse-plist/", "categories": "iOS, Guide", "tags": "ios, guide, modal, present, style", "date": "2022-11-22 10:44:00 +0000", "snippet": "앱을 개발하는 동안 수많은 테스트를 합니다. 그리고 그 테스트를 위해서는 데이터가 필요한데, 이를 목업 데이터라고 하지요. 만약 네트워크 통신으로 데이터를 가져오는 앱이라면 어떻게 할까요? 아직 네트워킹 모듈이 구현되어 있지 않아 어떻게 앱에 나타나는지 알 수 없다면요.이를 위해 Xcode에서는 목업 데이터를 하나의 파일로 만들어 사용할 수 있도록 하고 있습니다. 바로 plist입니다.물론 plist는 더 많은 일을 할 수 있지만 오늘은 목업 데이터 용으로 사용하는 방법을 소개해 볼까 합니다.plist로 데이터 만들기그럼 바로 plist를 만들어보겠습니다. 만드는 방법은 어렵지 않아요.앱에서 PropertyList 파일을 만들어주세요.Xcode는 데이터를 입력하는 방법으로 Property List와 Source Code라는 에디터 화면을 제공합니다.왼쪽 프로젝트 리스트에서 어떤 에디터를 사용할지 선택할 수 있어요.Property List에서 데이터 추가Root아래로 Key/Type/Value를 작성하면 됩니다.하지만!우리는 목업 데이터의 용도로 plist를 만들 생각이기 때문에 약간의 수정이 필요합니다.먼저 아래와 같이 Root아래에 array를 만들고 Root의 Type을 Array로, array의 Type을 Dictionary로 바꾸어 주세요.이제 이 item에 실제 앱에 뿌려질 데이터와 같은 Key와 Type을 작성해주시면 됩니다.(value까지 미리 넣으면 이따가 수정하기 힘드니 Key와 Type만 작성해주세요.)마지막으로 테스트할 갯수만큼 복사 &amp; 붙여넣기 해주세요.그리고 이제 각각의 value를 입력해주면 됩니다.Source Code에서 데이터 추가Source Code에서 입력하는 방법입니다.plist 우클릭-open as-Source Code를 선택해서 에디터 화면을 바꿔주세요.Source Code화면은 XML형태로 제공되기에 각각 키워드를 태그로 써서 열고, 닫아주면 됩니다.Property List 에디터 화면에서 작성한 내용은 아래와 같이 작성할 수 있습니다.이렇게 목업 데이터 용도로 plist를 만들어봤는데요, 어떠셨나요? 간단하죠?그럼 이제 어떻게 이 값을 가져올 수 있는지 살펴볼게요.plist 데이터 가져오기먼저 코드 부터 보시죠.그런데.. 딱히 부가적인 설명이 필요할 정도로 어려운 코드가 아니라서 주석을 참고해주시면 될 것 같습니다.struct Movies: Decodable { //Data형을 Movies형으로 바꾸기 위해 Decodable 프로토콜을 위임받는다. //plist에서 만든 Key와 변수의 이름이 동일해야 한다. //다른 변수명을 쓰고 싶다면 CodingKeys객체를 이용할 수 있다. let title: String let releseDate: String}private extension ViewController { func getPlistData() { let fileName = \"Movies\" //프로젝트에서 파일을 가져오기 위해서는 Bundle객체를 사용할 수 있다. //파라미터로 파일이름과 확장자를 전달한다. guard let url = Bundle.main.url(forResource: fileName, withExtension: \"plist\") else { return } do { //파일을 가져오는 작업은 예외처리를 위해 do { } catch { }를 쓴다. //Bundle객체로 불러온 파일을 Data형으로 변환한다. //Data형으로 변환된 파일을 다시 개발자가 사용하기 쉽게 Movies형으로 변환한다. let data = try Data(contentsOf: url) let result = try PropertyListDecoder().decode([Movies].self, from: data) //TODO } catch let error { print(\"error: \\(error.localizedDescription)\") } } }}어떠신가요? plist로 만든 목업 데이트를 완벽하게 가져오셨나요?만약 글에 잘못된 점이 있거나 실패하시는 분들은 메일을 보내 주세요~!메일보내기포스팅에 잘못된 부분이 있거나 궁금하신 점이 있다면, 왼쪽 사이드 하단 메뉴에서 로퍼즈팀으로 메일을 보내주세요!최대한 빠른 시간 내에 회신드릴게요! 감사합니다." }, { "title": "iOS, Git연동시 Pods파일등 불필요한 파일을 제외해서 올려보자, .gitignore사용법", "url": "/posts/add-ignore-file/", "categories": "iOS, Tip", "tags": "ios, tip, git, gitignore, pods제외", "date": "2022-11-21 14:00:00 +0000", "snippet": "앱 개발등 프로젝트를 진행하다보면 git을 사용할텐데요, 여러 컴퓨터 혹은 다른 팀원과 파일을 공유하다보면 몇몇 파일은 굳이 올리지 않아도 되지요. 그때 사용할 수 있는 방법이 바로 .gitignore파일의 존재입니다. 그런데 이 파일을 어떻게 작성해야 할까요? 아주 쉽게, 보다 효율적으로 만드는 방법을 소개할게요.문서를 만들어주는 사이트방법은 아주 간단합니다.아래 사이트를 참고하면 제외할 항목들을 한번에 정리해서 만들 수 있어요.https://www.toptal.com/developers/gitignore이렇게 업로드에 제외할 항목 키워드들을 입력하고 생성버튼을 누르면 아래와 같이 .gitignore에 작성할 내용을 볼 수 있습니다.내용을 복사해주세요..gitignore파일 만들기터미널을 열어 github에 올릴 프로젝트로 이동하고 아래와 같이 파일을 만들어 주세요.&gt; vim ./.gitignoregitignore 파일은 숨김파일로 만들어져야 하니 앞에 꼭 점(.)을 붙이는 걸 기억해주세요.이제 복사한 내용을 .gitignore파일에 붙여넣어 주세요.참, 여기에 .DS_Store도 같이 작성해서 넣어주시면 팀원과 보다 원할하게 코드를 공유할 수 있습니다..gitignore파일 업로드파일을 만들었다면 github로 올려줘야 겠죠?아래와 같이 git 명령어를 입력해주세요.&gt; git add ./.gitignore&gt; git commit -m \"uploaded .gitignore\"&gt; git push메일보내기포스팅에 잘못된 부분이 있거나 궁금하신 점이 있다면, 왼쪽 사이드 하단 메뉴에서 로퍼즈팀으로 메일을 보내주세요!최대한 빠른 시간 내에 회신드릴게요! 감사합니다." }, { "title": "iOS에서 willSet과 didSet 이렇게 쓸 수 있다.", "url": "/posts/how-to-use-willset-didset/", "categories": "Swift, Grammer", "tags": "swift, grammer, willset, didset", "date": "2022-11-16 12:11:00 +0000", "snippet": "클래스의 멤버변수 즉, 프로퍼티(Property)등에 장착할 수 있는 willSet, didSet은 변수의 상태를 감지하고 응답합니다. 그리고 iOS앱에서 레이블 또는 테이블뷰 및 컬렉션뷰등 값의 변화에 따라 새로고침이 필요한 순간에 아주 유용하게 사용할 수 있지요. 어려운 단어지만 어렵지 않은, 개념과 사용법을 잘 익혀서 보다 짧고 보다 효율적인 앱을 완성해보세요!프로퍼티 옵저버(Property Observer)애플은 willSet/didSet를 프로퍼티 옵저버라는 이름으로 부릅니다. 프로퍼티 옵저버(Property Observer)?말 그대로 클래스의 멤버변수의 변화를 관찰하는 것입니다.willSet/didSet을 말하고요.공부해보며 느낀점은 getter/setter와 같이 멤버변수의 값이 어떻게 변하는지 확인할 수 있다는 것이에요. getter/setter는 개발자가 직접 값을 확인해서 저장할 것인지 말것인지를 결정할 수 있었다면, willSet/didSet은 그냥 저장하되 이제 바뀌는 값, 혹은 전에 저장됐던 값을 확인하고 그에 따라 나머지 작업을 어떻게 할 것인지 결정해라의 차이랄까요?사용법개념을 살펴봤다면 이제 어떻게 사용할 수 있는지 정리해보죠.두 프로퍼티 옵저버는 저장 프로퍼티(Stored Property) 즉, 값을 저장하게 되는 멤버변수에 사용할 수 있어요.하지만, 사용하기 전에!프로퍼티 옵저버 willSet과 didSet을 쓰기 위한 조건이 있습니다.첫번째, 멤버변수가 반드시 초기화 되어 있어야 해요. 즉, 옵셔널 변수에는 사용할 수 없다는 것이죠.이는 내부적으로 감지할 변수의 실체가 있어야 하기 때문이지 않을까 해요. 존재하지도 않는 변수를 감시하고 있을 수 없을테니까요.이와 비슷한 이유로, 두번째, init()함수에서 초기화할 때도 willSet/didSet은 호출되지 않아요!자, 그럼 willSet과 didSet은 각각 언제 호출되고 어떤 값을 알려줄까요?willSet멤버변수에 값이 저장되기 바로 직전에 호출되어 “어떤 값이 저장될지”알려줍니다.// song.title = \"늑대가 나타났다.\"struct SongData { var title: String = \"비어있음\" { willSet { print(\"기존 : \\(title), 바뀔 값 : \\(newValue)\") } }}// 기존 : 비어있음, 바뀔 값 : 늑대가 나타났다만약 새로 들어온 값(newValue)이 특정 음악일 경우 따로 처리할 수 있겠네요.제목 색깔을 바꾸거나 굵게 말이죠.didSet역시 멤버변수에 값이 저장되기 전에 호출되지만 “현재 값 이전에 어떤 값이 저장되어 있었는지”를 알려줘요.//song.title = \"Sweet Dreams\"struct SongData { var title: String = \"비어있음\" { didSet { print(\"현재 : \\(title), 이전의 값 : \\(oldValue)\") } }}// 현재 : Sweet Dreams, 이전의 값 : 비어있음보통 저는 테이블뷰 또는 컬렉션뷰등을 새로고침할 때 주로 didSet을 쓰는데요,역시 willSet과 비슷하게 특정 값에 따라 분기처리할 수 있을 것 같습니다.iOS에서 써보기실제로 iOS앱을 만들면서 willSet과 didSet은 이렇게 사용할 수 있어요.//게임 타이틀을 표시하는 label 업데이트하기 위해 willSet 사용class VC: UIViewController { @IBOutlet weak var gameTitleLable: UILabel! private var gameTitle = \"\" { willSet { if checkGameTitle(newValue) { //새로 입력받은 타이틀이 진짜 게임 타이틀인지 확인 후, //true값을 return한다면, //그 때 gameTitleLabel을 바꾸어 줍니다. gameTitleLable.text = newValue } } }}//테이블뷰를 새로고침하기 위해 didSet 사용class VC: UIViewController { @IBOutlet weak var tableView: UITableView! private var game: [GameData] = [] { didSet { //didSet 프로퍼티 옵저버가 값이 바뀐 것을 감지하고 tableView.reload()를 수행합니다. tableView.reloadData() } } . . . func fetchData() { self.gameData = [ GameData(\"엘든링\", \"PC\") GameData(\"젤다의 전설\", \"닌텐도\") ] //fetchData()에서 gameData 값을 바꾸고 //tableView.reloadData()을 따로 명시 해줄 필요 없습니다. }}개인적으로는 willSet/didSet을 쓰는 것과 getter/setter쓰는 것은 비슷한 것 같습니다. 다만 그 사용 용도가 조금 다른데요, getter/setter가 캡슐화 특성을 살리기 위해, 즉 데이터의 값을 함부로 바꿀 수 없도록 하는데 초점이 맞춰져 있는데 반해 willSet/didSet은 기존의 값과 비교 혹은 특정 값을 감지하고 뷰를 업데이트 하는 데 있는 것 같습니다. 하지만 확실한건 iOS앱을 만들면서 willSet/didSet을 잘 사용하면 코드도 간결해고 효율적인 측면도 상승한다고 생각합니다.그 외 알아두면 좋아요. 멤버변수에는 willSet, didSet뿐만 아니라 get, set을 연결할 수도 있지만 각각이 하나의 쌍이되요. 그래서 하나의 멤버변수에는 하나만 연결할 수 있어요. 저장 프로퍼티만 프로퍼티 옵저버를 연결할 수 있지만 예외적으로 연산 프로퍼티에도 연결할 수 있어요.메일보내기포스팅에 잘못된 부분이 있거나 궁금하신 점이 있다면, 왼쪽 사이드 하단 메뉴에서 로퍼즈팀으로 메일을 보내주세요!최대한 빠른 시간 내에 회신드릴게요! 감사합니다." }, { "title": "iOS, UIKit 제스쳐 알아보기 3편 - Pan VS Swipe", "url": "/posts/PanVsSwipe/", "categories": "iOS, Util", "tags": "ios, UiKit, Gesture", "date": "2022-11-07 02:08:00 +0000", "snippet": "iOS, UIKit 제스쳐 알아보기 1편 - UIPanGesturehttp://loperz.com/posts/UIPanGesture/iOS, UIKit 제스쳐 알아보기 2편 - UISwipeGesturehttp://loperz.com/posts/UISwipeGesture/제스쳐 1편 포스팅에서 제스처의 종류에 대해서 사진으로만 알아 보았는데, 사실 공부를 하면서 대체 Pan 제스쳐와Swipe 제스쳐가 어떤 차이가 있는지 너무나 헷갈렸던 것. 아니 동작이 똑같은 것 같은데 왜 두개가 있는겨..?그래서 이번 포스팅에서는 Pan 제스쳐와 Swipe 제스쳐가 어떤 차이가 있는지에 알아보도록 하겠다.Pan VS Swipe제스쳐 1편과 2편에서 두 제스쳐에 대해 쓰임새는 알아보았다. 코드에서도 각 제스쳐의 특색이 많이 묻어났지만,왜 이 둘을 나눠놨을까 라는 생각이 들었다.이 두 제스쳐의 차이점이 너무 너무 궁금해서, 개발자들의 영원한 소울 플레이스인 스택오버플로우에 검색을 해 보았다.이 포스팅을 읽는 여러 뉴비분들의 검색 시간을 최소화 하기 위해 열심히 검색했으니 더 궁금하신 사항 있으시면아래 출처에서 참고해도 좋을 듯 하다.여기에 나오는 글 들을 번역해보면팬 제스쳐는 스와이프 제스쳐를 포함하는 개념입니다. 둘 다 터치 포인트의 병진 이동을 포함한다.병진 운동이란, 공간상에서 한 물체가 회전없이 이동하는 걸 뜻합니다.(저는 참고로 기계과출신입니다!) 만약, 공간상에서 원형 경로로 움직이면 회전하는 것 처럼 보일 수도 있지만, 물체 자체는 회전하지 않는다. (갑자기 물리시간…..)자 여기서, 두 제스쳐 다 평면상에서 터칭포인트가 움직이는 형태인건 알겠고…1) 터칭 포인트 관점터칭을 똑같이 했다 가정하고, 터칭 포인트의 움직임 관점에서 서술해보고자 한다.이전 1편과 2편에서도 알 수 있듯이, Pan 제스쳐는 움직임이 연속적인(Continuos) 움직임을 포함하고,Swipe 제스쳐는 방향이 정해진, 즉 개별적인(Discrete) 방향으로만 움직인다.(그래서 2편에서 개발문서의 워딩을 비교했는데, 제스쳐의 움직임이 연속적인(Continuous) VS 개별적인(Discrete)으로 표현되어 있었던 것 같다.)그래서, 1편과 2편의 움직이는 이미지를 비교해 보면, Pan 제스쳐에서는 연속적이고 2D평면상에서 방향에 구애받지 않는객체의 움직임을 보여줬고, Swipe 제스쳐에서는 제스쳐의 방향을 중점으로 보여줬었다.2) 사용자 터칭 모션 관점자, 1) 에서 터칭 포인트의 움직임 관점에서 설명을 했고, 이 둘의 실제 사용자 모션을 비교해보면 Swipe는 드래그 동작 후 손가락이 들어올려졌을 때 인식되어 콜백이 실행된다. Pan은 손가락이 움직이기 시작한 직후부터 인식되어 콜백이 실행된다.Swipe는 드래그 동작 후 손가락이 들어 올려졌을 때 인식되며, Pan은 손가락이 움직이기 시작한 직후에 거의 인식되기 때문에만약, 두 모션이 한번에 코드에 있는 경우 우선 순위는 Pan 제스쳐가 가지고 간다!3) 결론1) Pan 제스쳐가 Swipe 제스쳐보다 더 상위의 개념이라고 이해해도 된다. (사용자 터칭 모션이나 터칭 포인트의 움직임이나 모든 관점에서 봤을 때, Pan이 훨씬 더 다양한 움직임을 감지할 수 있다.)2) Pan제스쳐는 변환 이동의 시작을 찾고, 시간이 지남에 따라 어떤 방향으로든 계속해서 움직임을 캐치한다.3) 반면, Swipe제스쳐는 사용자의 터치가 필요한 방향으로 선형으로 이동했는지 여부를 결정하고, 제스쳐 실행 후 손가락이 화면에서 떼졌을 때 실행된다..로 정리할 수 있을 것 같다.물론 이해가 빠르면 굳이 이렇게 비교를 안해도 코드만보고도 이해를 했을테지만,나같은 뉴비를 대상으로 쓰는 포스팅이기에….ㅎ그럼 다음 블로그에서는 다른 제스쳐도 한번 알아보자!출처:https://stackoverflow.com/questions/9898627/what-is-the-difference-between-pan-and-swipe-in-ios메일보내기포스팅에 잘못된 부분이 있거나 궁금하신 점이 있다면, 왼쪽 사이드 하단 메뉴에서 로퍼즈팀으로 메일을 보내주세요!최대한 빠른 시간 내에 회신드릴게요! 감사합니다." }, { "title": "iOS, UIKit 제스쳐 알아보기 2편 - UISwipeGesture", "url": "/posts/UISwipeGesture/", "categories": "iOS, Util", "tags": "ios, UiKit, Gesture", "date": "2022-11-04 15:20:00 +0000", "snippet": "iOS, UIKit 제스쳐 알아보기 1편 - UIPanGesturehttp://loperz.com/posts/UIPanGesture/이번 포스팅에서는 Swipe 제스쳐에 대해서 알아보도록 하겠다.UISwipeGestureReconizer모든 포스팅에서 강조하듯, 개발자 문서를 한번 보고 넘어가보자! (진짜 웬만한 해답은 제공되는 개발자 문서에 다있는 듯 하다!)A discrete gesture recognizer that interprets swiping gestures in one or more directions.직역하면, 스와이프 제스처를 하나 이상의 방향으로 해석하는 개별 제스처 인식기 라고 하는데, 말그래도 스와이프 제스쳐와 그 방향에 따라서콜백을 호출하기 위한 클레스로 이해하면 될 것 같다.설명 상에서 지난 시간에 다뤘던 Pan 제스쳐와 다른 워딩을 찾아보면 Continuous VS Discrete direction정도가 있는 것 같은데, 설명만 봤을 떄는 스와이프 제스쳐는 연속성을 띄지 않는 제스쳐를 나타내는 것 같기도 하고제스쳐의 방향이 정형화 된 느낌을 준다. (둘의 차이는 다음 포스팅에서 다룰 예정이다!)백문불여일견이라고 설명보다는 눈으로 보는게 낫다! 코드로 어떻게 작동하는지 살펴 보자!EX1 - 기본 사용법(이라 읽고 삽질 후기)일단, UIPanGesture 를 한번 사용해봤기 때문에, 모든 제스쳐를 다 할 수 있을것만 같았다.호기롭게 중간에 이미지 뷰를 하나 넣고, 이 이미지 뷰를 스와이프 하는 방향으로 콘솔을 띄워보고자 했다.기본적으로 UIPanGesture와 사용방법이 매우 매우 매우 흡사하다. 근데, UISwipeGesture 에서는제스쳐 인스턴스를 선언하고, 반드시….반드시!!!스와이프 방향을 꼭 꼭 꼭 설정해주어야 한다!!! (호기롭게 UIPanGesture 처럼 썼다가 계속 안되서 한참 해맸다…)참고로, 스와이프 방향을 지정해주지 않으면 우측 스와이프 방향이 기본으로 설정된다. 방향을 설정해주지 않고, 상/하/좌/우 열심히 스와이프 해보는데 계속 우측만 떴다….아래 코드를 보자.import Foundationimport UIKitclass ViewController3: UIViewController { @IBOutlet weak var imageView: UIImageView! @IBOutlet weak var dirLabel: UILabel! @IBOutlet weak var returnButton: UIButton! override func viewDidLoad() { super.viewDidLoad() let gesture = UISwipeGestureRecognizer(target: self, action: #selector(swipeUpActionWithSingle)) //이거..이거!!! 꼭 등록해줘야한다. 난 위쪽 방향 스와이프를 등록했다! gesture.direction = .up //제스쳐 등록 imageView.addGestureRecognizer(gesture) } //제스쳐 실행 시 콜백 함수 @objc func swipeUpActionWithSingle(_ sender: UISwipeGestureRecognizer) { let swipeDir = sender.direction switch swipeDir { case .up : dirLabel.text = \"위로!위로!\" imageView.image = UIImage(systemName: \"circle.grid.cross.up.filled\") case .down : dirLabel.text = \"아래로!아래로!\" imageView.image = UIImage(systemName: \"circle.grid.cross.down.filled\") case .right : dirLabel.text = \"우로!우로!\" imageView.image = UIImage(systemName: \"circle.grid.cross.right.filled\") case .left : dirLabel.text = \"좌로!좌로!\" imageView.image = UIImage(systemName: \"circle.grid.cross.left.filled\") default: break } } //이건 그냥... 반복해서 보여줄려고 원복시키는 버튼 콜백 @IBAction func toInitialCondition(_ sender: Any) { dirLabel.text = \"방향\" imageView.image = UIImage(systemName: \"circle.grid.cross\") }}저 플레이스테이션 방향키 같은 이미지 뷰를 위로 쓸어올리면, 변하는 뷰를 볼 수 있다.EX2 - 응용(4방향)별로 다른게 없다. 그냥 제스쳐의 인스턴스를 4개 선언하고, 4방향을 각각 등록해 준 다음 콜백은 기존에 있던 함수를 써보자.import Foundationimport UIKitclass ViewController3: UIViewController { @IBOutlet weak var imageView: UIImageView! @IBOutlet weak var dirLabel: UILabel! @IBOutlet weak var returnButton: UIButton! override func viewDidLoad() { super.viewDidLoad() // Do any additional setup after loading the view. let gestureUp = UISwipeGestureRecognizer(target: self, action: #selector(swipeUpActionWithSingle)) gestureUp.direction = .up let gestureDown = UISwipeGestureRecognizer(target: self, action: #selector(swipeUpActionWithSingle)) gestureDown.direction = .down let gestureLeft = UISwipeGestureRecognizer(target: self, action: #selector(swipeUpActionWithSingle)) gestureLeft.direction = .left let gestureRight = UISwipeGestureRecognizer(target: self, action: #selector(swipeUpActionWithSingle)) gestureRight.direction = .right //제스쳐 등록 imageView.addGestureRecognizer(gestureUp) imageView.addGestureRecognizer(gestureDown) imageView.addGestureRecognizer(gestureLeft) imageView.addGestureRecognizer(gestureRight) } //제스쳐 실행 시 콜백 함수 @objc func swipeUpActionWithSingle(_ sender: UISwipeGestureRecognizer) { let swipeDir = sender.direction switch swipeDir { case .up : dirLabel.text = \"위로!위로!\" imageView.image = UIImage(systemName: \"circle.grid.cross.up.filled\") case .down : dirLabel.text = \"아래로!아래로!\" imageView.image = UIImage(systemName: \"circle.grid.cross.down.filled\") case .right : dirLabel.text = \"우로!우로!\" imageView.image = UIImage(systemName: \"circle.grid.cross.right.filled\") case .left : dirLabel.text = \"좌로!좌로!\" imageView.image = UIImage(systemName: \"circle.grid.cross.left.filled\") default: break } } @IBAction func toInitialCondition(_ sender: Any) { dirLabel.text = \"방향\" imageView.image = UIImage(systemName: \"circle.grid.cross\") }}포인터가 안보이지만 열심히 움직이고 있다……EX3 - 응용2(두손가락 모드)이번에는 두 손가락을 사용해 보자. “numberOfTouchesRequired” 프로퍼티에다가터치할 손가락 개수를 숫자로 넣어주면 된다.(해당 프로퍼티는 정수형 setter 프로퍼티다!)그리고, 원래 있던 코드에다가 한손가락 모드인지 두손가락 모드인지 띄우는 라벨까지 추가해서한번 보도록 하자.비교를 위해 한손가락 모드일 떄의 제스쳐 인스턴스와, 두 손가락일 때의 제스쳐 인스턴스 전부 선언하고똑같이 이미지 뷰에 제스처 등록을 해준다. 그리고, 두 손가락일 때의 제스쳐의 “numberOfTouchesRequired” 프로퍼티에 손가락 2개를 선언해주었다.아래 코드를 보자!import Foundationimport UIKitclass ViewController3: UIViewController { @IBOutlet weak var imageView: UIImageView! @IBOutlet weak var dirLabel: UILabel! @IBOutlet weak var returnButton: UIButton! @IBOutlet weak var numberOfFingerLabel: UILabel! override func viewDidLoad() { super.viewDidLoad() // Do any additional setup after loading the view. let gestureUp = UISwipeGestureRecognizer(target: self, action: #selector(swipeUpActionWithOneFinger)) gestureUp.direction = .up let gestureDown = UISwipeGestureRecognizer(target: self, action: #selector(swipeUpActionWithOneFinger)) gestureDown.direction = .down let gestureLeft = UISwipeGestureRecognizer(target: self, action: #selector(swipeUpActionWithOneFinger)) gestureLeft.direction = .left let gestureRight = UISwipeGestureRecognizer(target: self, action: #selector(swipeUpActionWithOneFinger)) gestureRight.direction = .right //제스쳐 등록 imageView.addGestureRecognizer(gestureUp) imageView.addGestureRecognizer(gestureDown) imageView.addGestureRecognizer(gestureLeft) imageView.addGestureRecognizer(gestureRight) let gestureUpTwoFinger = UISwipeGestureRecognizer(target: self, action: #selector(swipeUpActionWithTwoFinger)) gestureUpTwoFinger.direction = .up gestureUpTwoFinger.numberOfTouchesRequired = 2 //손가락 개수! let gestureDownTwoFinger = UISwipeGestureRecognizer(target: self, action: #selector(swipeUpActionWithTwoFinger)) gestureDownTwoFinger.direction = .down gestureDownTwoFinger.numberOfTouchesRequired = 2 //손가락 개수! let gestureLeftTwoFinger = UISwipeGestureRecognizer(target: self, action: #selector(swipeUpActionWithTwoFinger)) gestureLeftTwoFinger.direction = .left gestureLeftTwoFinger.numberOfTouchesRequired = 2 //손가락 개수! let gestureRightTwoFinger = UISwipeGestureRecognizer(target: self, action: #selector(swipeUpActionWithTwoFinger)) gestureRightTwoFinger.direction = .right gestureRightTwoFinger.numberOfTouchesRequired = 2 //손가락 개수! //제스쳐 등록 imageView.addGestureRecognizer(gestureUp) imageView.addGestureRecognizer(gestureDown) imageView.addGestureRecognizer(gestureLeft) imageView.addGestureRecognizer(gestureRight) imageView.addGestureRecognizer(gestureUpTwoFinger) imageView.addGestureRecognizer(gestureDownTwoFinger) imageView.addGestureRecognizer(gestureLeftTwoFinger) imageView.addGestureRecognizer(gestureRightTwoFinger) } //손가락 한개 스와이프 콜백 @objc func swipeUpActionWithOneFinger(_ sender: UISwipeGestureRecognizer) { let swipeDir = sender.direction numberOfFingerLabel.text = \"손가락 한개 감지\" switch swipeDir { case .up : dirLabel.text = \"위로!위로!\" imageView.image = UIImage(systemName: \"circle.grid.cross.up.filled\") case .down : dirLabel.text = \"아래로!아래로!\" imageView.image = UIImage(systemName: \"circle.grid.cross.down.filled\") case .right : dirLabel.text = \"우로!우로!\" imageView.image = UIImage(systemName: \"circle.grid.cross.right.filled\") case .left : dirLabel.text = \"좌로!좌로!\" imageView.image = UIImage(systemName: \"circle.grid.cross.left.filled\") default: break } } //손가락 두개 스와이프 콜백 @objc func swipeUpActionWithTwoFinger(_ sender: UISwipeGestureRecognizer) { let swipeDir = sender.direction numberOfFingerLabel.text = \"손가락 두개 감지\" switch swipeDir { case .up : dirLabel.text = \"위로!위로!\" imageView.image = UIImage(systemName: \"circle.grid.cross.up.filled\") case .down : dirLabel.text = \"아래로!아래로!\" imageView.image = UIImage(systemName: \"circle.grid.cross.down.filled\") case .right : dirLabel.text = \"우로!우로!\" imageView.image = UIImage(systemName: \"circle.grid.cross.right.filled\") case .left : dirLabel.text = \"좌로!좌로!\" imageView.image = UIImage(systemName: \"circle.grid.cross.left.filled\") default: break } } @IBAction func toInitialCondition(_ sender: Any) { dirLabel.text = \"방향\" imageView.image = UIImage(systemName: \"circle.grid.cross\") numberOfFingerLabel.text = \"손가락 몇개?\" }}두개일 떈 마우스 포인터가 보이던데… 시뮬레이터 레코딩에서 없는채로 녹화를 해버리네…어쩄든 열시미 움직이고 있다!메일보내기포스팅에 잘못된 부분이 있거나 궁금하신 점이 있다면, 왼쪽 사이드 하단 메뉴에서 로퍼즈팀으로 메일을 보내주세요!최대한 빠른 시간 내에 회신드릴게요! 감사합니다." }, { "title": "iOS, UIKit 제스쳐 알아보기 1편 - UIPanGesture", "url": "/posts/UIPanGesture/", "categories": "iOS, Util", "tags": "ios, UiKit, Gesture", "date": "2022-10-26 13:52:00 +0000", "snippet": "우리가 스마트폰을 쓸 때 화면을 터치를 하거나, 드래그 혹은 두 손가락으로 사진을 확대하는 동작을 가장 많이 사용하는 것 같다.이번 포스팅에서는 여러가지 동작 중 화면을 드래그 하는 동작을 받아서 뷰를 동작시키는 것을 알아보자.제스처의 종류xcode의 스토리보드 상에서 “+” 버튼을 눌러서 gesture를 검색하면 위 사진처럼 앱에서 사용할 수 있는 동작들이 나온다. 나중에 하나씩 다뤄보도록 하고 이번 포스팅에서는 Pan Gesture Reconigzer를 사용해보자.UIPanGestureReconizer언제나 그렇듯, 개발자의 좋은 자세로 여겨지는 것이 항상 공식 개발 문서를 참고하는 것이다. 공식 문서를 먼저 살펴보면A continuous gesture recognizer that interprets panning gestures.패닝 제스쳐를 해석하는 연속적인 제스처 인식기(직역하면 그렇다) 라고 번역이 되는데 여기서 말하는 패닝 동작은 터치 후 드래그 동작을 뜻한다.(사실 명확하게 뜻이 안나와있어서 여러 다른 분야의 포스팅을 찾아 봤는데 카메라 촬영 기법에도 나오고 포토샵에도 비슷한 용어들 나온다. 포토샵에서는 클릭 후 드래그해서 객체를 움직이는 액션을 뜻한다.)어떤 앱에서 스티커를 이용해서 사진을 꾸밀 때 스티커를 터치해서 움직인 다음 원하는 위치에 배치하는 동작(?)으로 생각하면 좋을 것 같고, 그냥 뭔가를 움직이지 않더라도 직선 모션은 다 감지한다.그럼, 이 제스쳐가 코드에서 어떻게 작동하는지 한번 알아보자.EX1 - 단순 뷰 이동!화면에 떠있는 이미지 뷰를 이동시키는 간단한 코드 예제를 준비해 보았다. 당연히 이미지 뷰는 화면 외부를 튀어나가면 안되는 것을 전제로 만들었다.일단 스토리보드를 연 다음, 중간에 이미지 뷰를 하나 만들어서 원하는 배경색을 넣든 이미지를 넣어서 배치를 해보자.(공돌이들에게 디자인은 너무나 어려운 영역인것…)그리고 반드시!! 우측 인스펙터 창에서 “User Interaction Enable” 항목을 반드시 체크해야 한다!그 다음, 해당 뷰컨트롤러에 연결되어 있는 ViewContoller.swift에 가서 스토리보드에 추가해 준 이미지뷰 객체를 선언한 다음, viewDidLoad 함수에 다음 코드를 넣어보자.(아래 코드 참조)import UIKitclass ViewController1: UIViewController { //추가한 이미지 뷰 객체 선언. 당연히 스토리보드와 연결되어 있어야 함. @IBOutlet weak var imageView: UIImageView! //UIScreen.main.bounds -&gt; 현재 기기의 외곽 사이즈를 CGRect로 반환해줌. let bounds: CGRect = UIScreen.main.bounds override func viewDidLoad() { super.viewDidLoad() //난 공돌이이기 떄문에 대강 SF Symbol로 이미지 뷰에 동그라미를 넣어보았다. imageView.image = UIImage(systemName: \"circle.fill\") //UIView를 상속하는 객체에 제스쳐 전달. #selector 로 콜백함수 전달 let gesture = UIPanGestureRecognizer(target: self, action: #selector(dragObject)) //제스쳐 등록 -&gt; addGestureRecognizer 메서드는 UIView의 메서드이기 때문에 UIView를 상속받는 모든 //객체에서 사용 가능하다! imageView.addGestureRecognizer(gesture) } //제스쳐 실행 시 콜백 함수 -&gt; 위 이미지 뷰에서 등록한 제스쳐가 실행될 때 마다 dragObject를 실행시키며, //그 매개변수로 UIPangGestureRecognizer 타입의 sender를 보낸다. @objc func dragObject(_ sender: UIPanGestureRecognizer) { let location = sender.location(in: view) //등록한 이미지 뷰의 현재 위치 let draggedView = sender.view! //현재 드래그 하고자 하는 뷰. 즉 이미지 뷰를 뜻한다. if (location.x &lt; imageView.frame.width/2) { draggedView.center.x = imageView.frame.width //현재 사람 손의 위치가 스마트폰 좌측에서 이미지 뷰 폭의 1/2구간일 때, //스마트 폰의 좌측으로 튀어나가지 않도록! } else if (location.x &gt; bounds.maxX - imageView.frame.width/2) { draggedView.center.x = bounds.maxX - imageView.frame.width/2 //현재 사람 손의 위치가 스마트폰 우측에서 이미지 뷰 폭의 1/2구간일 떄, //스마트 폰의 우측으로 튀어나가지 않도록! (bounds.maxX!) } else { draggedView.center = location //그 외에는 움직이는 뷰의 센터는 현재 손가락의 위치를 그대로 따라간다! } }}EX2 - 뷰 방향 인식!이번에는 드래그 하는 방향을 인식하도록 만들어 보았다. 위 예제처럼 똑같이 동작하는 뷰를 만들고, 드래그 방향을 라벨에 띄우도록 만들어 보자.위 코드와 비슷한데, 방향을 문자열로 띄우도록 스토리보드에 라벨을 하나 추가하였고, dragObject 콜백 함수에 sender.velocity라는 메서드가 하나 더 생겼다.이는, 드래그 방향에 따라 속도를 CGFloat 으로 반환해 준다.!! 속도니까 당연히 부호도 있다. +,-로 반환하기 떄문에 어느 방향으로 드래그가 되고있는 지 알 수 있다.참고로, 기기의 좌측 최상단이 0,0이고, 이를 기준으로 우측으로 가면 +X 방향,아래로 가면 +Y 방향이다. (다 아실거라 믿습니다!)import UIKitclass ViewController2: UIViewController { @IBOutlet weak var labelDir: UILabel! @IBOutlet weak var controlDirView: UIImageView! let bounds: CGRect = UIScreen.main.bounds override func viewDidLoad() { super.viewDidLoad() //방향을 보여줄 라벨! labelDir.text = \"haha\" //나머지는 똑같다. let gesture = UIPanGestureRecognizer(target: self, action: #selector(dragObject)) //제스쳐 등록 controlDirView.addGestureRecognizer(gesture) } //제스쳐 실행 시 콜백 함수 @objc func dragObject(_ sender: UIPanGestureRecognizer) { let location = sender.location(in: view) let draggedView = sender.view! //x방향의 속도를 절대값 처리하여 y속도 절대값 보다 클 때, 분기 if abs(sender.velocity(in: self.view).x) &gt; abs(sender.velocity(in: self.view).y) { //x방향 속도가 음수 일 때, (좌측 방향 드래그) if (sender.velocity(in: self.view).x &lt; 0) { labelDir.text = \"좌\" } else { //그 외 labelDir.text = \"우\" } //y방향의 속도를 절대값 처리하여 x속도 절대값 보다 클 때, 분기 } else if abs(sender.velocity(in: self.view).x) &lt; abs(sender.velocity(in: self.view).y) { //y방향 속도가 양수 일 때, (아래 방향 드래그) if (sender.velocity(in: self.view).y &gt; 0) { labelDir.text = \"하\" } else { //그 외 labelDir.text = \"상\" } } b if (location.x &lt; controlDirView.frame.width/2) { draggedView.center.x = controlDirView.frame.width/2 } else if (location.x &gt; bounds.maxX - controlDirView.frame.width/2) { draggedView.center.x = bounds.maxX - controlDirView.frame.width/2 } else { draggedView.center = location } }}이렇게 하면 뷰가 이동하는 방향을 상/하/좌/우로 나누어서 라벨에 표시가 된다. (콜백함수는 뷰를 드래그하여 이동시킬 때 마다 실행되기 때문에 라벨에 표시도 계속해서 업데이트 시킨다!)그리고, 2번 예제에서 뷰가 조금 끊겨 보이는 현상이 있는데, 뭔가 다른 셋팅이 필요한 것 같다. (매끄럽게 처리하는 방법을 계속 찾아보겠다.)메일보내기포스팅에 잘못된 부분이 있거나 궁금하신 점이 있다면, 왼쪽 사이드 하단 메뉴에서 로퍼즈팀으로 메일을 보내주세요!최대한 빠른 시간 내에 회신드릴게요! 감사합니다." }, { "title": "iOS 네트워킹으로 많은 데이터를 테이블뷰로 페이징하는 방법", "url": "/posts/prefetch-data-source-of-tableview/", "categories": "iOS, Util", "tags": "ios, util, tableview", "date": "2022-10-24 14:09:00 +0000", "snippet": "보통 많은 데이터를 보여주는 방법으로 테이블뷰 또는 컬렉션뷰를 이용하곤 한다.이번 포스팅에서는 네트워크 통신시 많은 데이터를 보여줄때, 페이지 단위로 보여주고 특정 시점에 다음 페이지에 해당하는 데이터를 재요청하는 방법을 정리했다.prefetchDataSource 프로토콜애플 도큐먼트에서 말하는 prefetchDataSource의 설명을 보면,The object that acts as the prefetching data source for the table view,receiving notifications of upcoming cell data requirements.사전 데이터 원본 역할을 하는 개체로, 다가올 셀 데이터 요구 사항에 대한 알림을 받습니다.무슨 말인지 썩 한번에 와닿지 않는다..간단하게 말해서 앞으로 불러올 Cell의 index값을 받는것으로 생각하면 간단하다.무슨 말이냐면, 현재 6번째 cell을 보여주고 있을 때 아래 메서드의 indexPaths값을 print구문으로 찍어보면 12, 13, 14.. 등의 인덱스값을 가지는 것을 확인할 수 있다.이제 테이블 뷰를 통한 예시를 보면 조금 더 이해할 수 있을 것이다.Usage테이블 뷰 또는 컬렉션 뷰 모두 사용법은 동일하다.차이점이 있다면,테이블 뷰는 UITableViewDataSourcePrefetching 프로토콜을 채택하고,컬렉션 뷰는 UICollectionViewDataSourcePrefetching 프로토콜을 채택한다.먼저 viewDidLoad()에서 프로토콜을 채택한다.override func viewDidLoad() { ... tableView.prefetchDataSource = self}이 프로토콜을 채택하면 반드시 구현해야 하는 메서드가 있다.UITableViewDataSourcePrefetching을 확장해서 prefetchRowsAt 메서드를 구현하면 된다.extension VC: UITableViewDataSourcePrefetching { func tableView(_ tableView: UITableView, prefetchRowsAt indexPaths: [IndexPath]) { //TO DO }}TO DO부분에는 앞으로 불러올 인덱스 값(IndexPaths)이 불러올 다음 페이지 번호와 일치하는 지를 확인 후, 일치한다면 해당 페이지 번호를 파라미터로 재요청 하면 된다.class VC: UITableViewController { var currPage = 1 //데이터를 성공적으로 가져왔을 때 페이지가 증가한다. override func viewDidLoad() { ... tableView.prefetchDataSource = self }}extension VC: UITableViewDataSourcePrefetching { func tableView(_ tableView: UITableView, prefetchRowsAt indexPaths: [IndexPath]) { //첫번째 페이지라면 다시 데이터를 요청할 필요가 없기 때문에 //2번째 페이지일때부터 작동하도록 한다. if self.currentPage != 1 { indexPaths.forEach({ if ($0.row + 1)/&lt;한 페이지에 보여줄 개수&gt; + 1 == self.currPage { self.fetchDatas(of: self.currPage) } }) } }}단, 이 방법을 사용하기 위해서는 API에서 page번호에 대한 파라미터를 제공해야 한다.메일보내기포스팅에 잘못된 부분이 있거나 궁금하신 점이 있다면, 왼쪽 사이드 하단 메뉴에서 로퍼즈팀으로 메일을 보내주세요!최대한 빠른 시간 내에 회신드릴게요! 감사합니다." }, { "title": "프로그래밍에 디자인 패턴이 무슨 말이야?", "url": "/posts/what-is-design-pattern/", "categories": "프로그래밍, 개념", "tags": "ios, 프로그래밍, 개념, 디자인패턴", "date": "2022-10-20 00:13:00 +0000", "snippet": "MVC, MVVM 등 기업에서 요구하는 스펙들이 있다. 바로 디자인 패턴이 그것인데, 알면서도 모를듯한 개념이다.그 개념에 대해 확실히 할겸 정리했다.디자인 패턴이란?먼저, 디자인 패턴?? 뭔가 프로그래밍과 그렇게 연관이 있을 것 같지 않은 단어들이다. 사실 따지고보면 iOS앱도 하나의 큰 제품이지 않은가, 소프트웨어라는 제품말이다.즉, 제품을 만들기 위해 설계도가 필요하다는 말씀! 그리고 디자인 패턴이 이 설계도를 어떻게 단순화 할지, 어떻게 재사용할지, 어떻게 유지보수를 쉽게 할 수 있게 할 것인지 가이드라인을 제시한다고 생각하면 된다.여기 자동차를 만들기 위한 설계도가 있다.이 한장의 설계도는 그 어떤 디자인 패턴도 않고발퀄이지만.. 자동차 설계도입니다.이때! 클라이언트가 바퀴를 바꾸고 싶다고 한다. Oh my god…열심히 지금 바퀴가 좋다고, 어울린다고 설득해보지만 소용없다.이제 새로운 바퀴를 그려야 한다.그럼 이 설계도에서 바퀴 부분만 찢어야 할까?아니면 위에 새로운 종이로 덮어야 할까?만약 각 부분을 각각의 종이에 그렸다면 클라이언트의 당황스러운 요청에도 1도 당황하지 않고 바꿀 수 있었을 것이다.이것이 디자인 패턴을 적용해서 코딩해야 하는 이유다.즉 디자인 패턴은,프로그램의 구조를 단순화하고 유지보수를 쉽게 하기 위한 하나의 전략이다.장점 변화하는 요구에 빠른 대응이 가능하다. 각각을 모듈화해서 재사용성이 증가한다. 유지보수가 편하다. 소스 코드가 단순해지고 보기 쉬워진다.단점 객체지향 프로그래밍 기반이기 때문에 설계시 고려해야 한다. 프로그램의 전체적인 그림을 그리는데 돈과 시간이 많이 소요된다.(비용 증가)예시보편적으로 많이 쓰이는 디자인 패턴 MVC를 적용하기 전 코드와 적용한 후의 코드를 비교해보면 조금 더 명확하다.iOS앱에서 TableView구현을 예로 보자MVC 디자인 패턴 적용하기 전TableVC.swiftclass TableVC: UITableViewController { //과일 데이터 var fruits = [\"Apple\", \"Banana\", \"Grape\", \"Mango\", \"Strawberry\", \"blueberry\"] override func viewDidLoad() { super.viewDidLoad() . . . tableView.register(FruitListCell.self, forCellReuseIdentifier: \"FruitListCell\") }}//TableViewDataSourceextension TableVC { . . . override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell { let cell = tableView.dequeueReusableCell(withIdentifier: \"FruitListCell\") as! FruitListCell let fruit = fruits[indexPath.row] cell.fruitNameLabel.text = fruit //컨트롤러에서 직접 Cell의 멤버변수에 접근한다. return cell }}위 코드를 보면 데이터 또는 cell의 변경사항이 발생했을 경우, Controller의 코드를 수정해야 한다.예시 코드는 TableView 구현중에서도 일부분만 가져와서 “까짓 바꾸면 되지”할 수도 있지만, 만약 코드가 몇백 몇천줄이 되면 감히 얼마나 많은 수고가 있을지 상상도 되지 않는다.반면 적용 후 예시에서는 각각의 부분만 수정해주면 되는 것을 알 수 있으며, 각각의 부분이 컨트롤러와 나뉘어 있어 독립적으로 실행된다. 이는 모듈화로써 재사용성이 증가한다는 것이고 단순해졌다는 것을 의미하기도 한다.MVC 디자인 패턴 적용 후Fruit.swift(Model)struct FruitModel { //데이터 변경 요청시 이 파일만 수정하면 된다. private var fruits = [\"Apple\", \"Banana\", \"Grape\", \"Mango\", \"Strawberry\", \"blueberry\"] func getFruitName(idx: Int) -&gt; String { return fruits[idx] }}TableViewItem.swift(View)struct TableViewItem: UITableViewCell { @IBOutlet weak var fruitName: UILabel func setUpFruitName(_ fruit: Fruit) { self.fruitName = fruit.name }}TableVC.swift(Controller)class TableVC: UITableViewController { let fruitModel = FruitModel() override func viewDidLoad() { super.viewDidLoad() . . . tableView.register(FruitListCell.self, forCellReuseIdentifier: \"FruitListCell\") }}//TableViewDataSourceextension TableVC { . . . override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell { let cell = tableView.dequeueReusableCell(withIdentifier: \"FruitListCell\") as! FruitListCell let fruit = fruitModel.getFruitName(idx: indexPath.row) cell.setUpFruitName(fruit) //데이터만 넘겨줄 뿐 cell에 직접적으로 관여하지 않는다. return cell }}메일보내기포스팅에 잘못된 부분이 있거나 궁금하신 점이 있다면, 왼쪽 사이드 하단 메뉴에서 로퍼즈팀으로 메일을 보내주세요!최대한 빠른 시간 내에 회신드릴게요! 감사합니다." }, { "title": "Swift, URL에 http:// 자동으로 채워넣는 방법", "url": "/posts/add-html-automatically/", "categories": "Swift, Util", "tags": "swift, ios, util, http, web", "date": "2022-10-18 01:23:00 +0000", "snippet": "iOS의 Webkit으로 웹페이지를 띄울 때 URL을 전달한다.이때 이 URL은 “http://…” 또는 “https://…“로 시작되지 않으면 정상적으로 웹페이지가 뜨지 않는다.우린 PC에서도 그렇지만 주소입력바 등의 UI에 늘 하던대로 ‘naver.com’ 입력하곤 한다.이 방법은 iOS에서도 그렇게 입력되는 것을 방지한다.함수로 만들어 사용할 수도 있고,let urlWithHttp:String = addHTMLAuto(urlStr)//'http://' 자동 삽입func addHTMLAuto(_ url:String) -&gt; String { var strUrl = \"\" var flag = false if strUrl.hasPrefix(\"http://\") || strUrl.hasPrefix(\"https://\") { flag = true } if (!flag) { strUrl = \"http://\" + url } return strUrl}String을 확장(Extension)해서 사용할 수도 있다.let urlWithHttp:String = urlStr.addHTMLAuto()//'http://' 자동 삽입func addHTMLAuto() -&gt; String { var strUrl = \"\" var flag = false if self.hasPrefix(\"http://\") || self.hasPrefix(\"https://\") { flag = true } if (!flag) { strUrl = \"http://\" + self } return strUrl}메일보내기포스팅에 잘못된 부분이 있거나 궁금하신 점이 있다면, 왼쪽 사이드 하단 메뉴에서 로퍼즈팀으로 메일을 보내주세요!최대한 빠른 시간 내에 회신드릴게요! 감사합니다." }, { "title": "iOS, Swift Down Casting 이해하기", "url": "/posts/class-down-casting/", "categories": "Swift, Grammer", "tags": "swift", "date": "2022-10-17 14:00:00 +0000", "snippet": "다운캐스팅!객체지향 언어를 공부하면서 가장 헷갈렸던 개념이 아니였던가 싶다. 상속까지는 어찌저찌 이해를 했는데상속이 되면 부모/자식 클래스 인스턴스에서 어떤 특성이 생기는지 이해하는데 참 많은 시간이 걸렸다.상속의 개념을 가장 잘 설명하는, 또는 부모/자식 클래스를 넘나들면서 객체지향 패러다임을 잘 활용할 수있는 개념이 다운캐스팅이라 생각하여 본 포스팅을 쓰게 되었다.다운캐스팅을 설명하기 위해서는 클래스간 상속이 전제가 되어야 한다. 상속된 클래스는 유용한 특성이너무나도 많기 때문에 본 포스팅에선 상속에 대해 어느 정도 안다고 생각하고 시작하겠다.코드 예시 정의!모든 클래스/상속에 대한 포스팅이 그렇듯이, 적절한 예시로 시작을 하고자 한다.한국과 미국에 스마트폰을 팔아먹는 제조업자 컨셉으로 설명을 시작하겠다.먼저, 한국과 미국에 파는 스마트폰에 대해 기능 정의를 먼저 하고, 코드로 넘어가보자공통기능: 언어, 전화기능 한국: 공통 기능 + 카메라 셔터음미국: 공통 기능 + 녹음 기능일단, 공통 기능과 한국과 미국에 특화된 기능들을 정의했다. 그리고, 이를 생산해서테스트 까지 해보는 예시 코드를 준비해 보았다.//공통 기능 클래스 정의class CommonFunction { var language: String = \"\" //디바이스 언어 func call() { //전화 기능 print(\"Common Call\") }}class ToKorea: CommonFunction { //공통기능 상속 &amp; 한국 폰 기능 정의 override func call() { //공통 기능의 전화 기능을 한국에 맞게 정의 print(\"Call in korean\") } func cameraShutterSound() { // 한국 전용 카메라 사운드 정의 print(\"Chal-kak!\") }}class ToUSA: CommonFunction { //공통기능 상속 &amp; 미국 폰 기능 정의 override func call() { //공통 기능의 전화 기능을 미국에 맞게 정의 print(\"Call in English\") } func voiceRecording() { //녹음 기능 print(\"recording\") }}자, 이제 기능이 대한 정의를 클래스로 표현하였고, 이를 어떻게 다운캐스팅에 접목해서 사용할 수 있는지살펴보자.휴대폰 품질검사 한번 해봅시다!자 여기서, 프로세스를 하나 추가하자.//샘플을 품질 검사하는데로!var qualityChecking: [CommonFunction] = []let toKorea1: ToKorea = ToKorea()let toUSA1: ToUSA = ToUSA() qualityChecking.append(toKorea1)qualityChecking.append(toUSA1)미국 전용 휴대폰과 한국 전용 휴대폰을 각각 1대씩 샘플로 선정하여 품질 검사를 실시하려고 한다.qualityChecking 이라는 변수를 하나 선언해서, CommonFunction(공통 기능)을 요소로 하는배열 타입을 일단 빈 배열로 선언하자.그리고, toKorea1, toUSA1 이라는 완제품을 하나씩 선정하여 인스턴스를 선언하여, 품질 검사 샘플 배열에 append하여 추가를 한다.이 때, 우리가 확인할 수 있는 것이 분명 품질 검사 배열은 CommonFunction 타입으로 되어있는데, 어떻게 ToKorea, ToUSA를 요소로 append가 가능한거지? 라는 의문을 가질 수가 있다.이 때, 나오는 개념이 업캐스팅이다. 부모 클래스의 타입에, 자식 클래스를 대입하는 걸 업캐스팅이라 하는데,부모 클래스 타입에 자식 클래스 인스턴스를 대입할 수 있는 이유가, 자식 클래스는 부모 클래스의 특성을전부 가지고 있기 때문에 대입이 가능하다!그렇기 때문에, 업캐스팅은 무조건 성공한다 라고 생각하면 된다var son: ToKorea = ToKorea()var parents: CommonFunction = son as CommonFunction이랑 똑같은 말인데, son 뒤에 as CommonFunction을 굳이 붙이지 않아도, 암시적으로parent에 son 변수 대입이 가능해진다. 그래서, 캐스팅이라는 개념은 그렇게 중요하게 다루지 않는다.(그냥 되는거니까, 굳이 이름 붙여서 헷갈리지 말자구요!)자, 다시 본론으로 돌아와서우리는 한국폰1, 미국폰1을 하나씩 샘플로 가져와서 품질 검사를 하도록 넘겼다.품질 검사하는 배열의 타입이 CommonFunction인데, 과연 여기서 다운캐스팅이 어떻게 쓰였는지다음 코드를 보자!for sample in qualityChecking { if let temp = sample as? ToKorea { //다운캐스팅 temp.call() temp.cameraShutterSound() } if let temp = sample as? ToUSA { temp.call() temp.voiceRecording() }}for - in 구문으로, 샘플로 들어온 배열의 요소를 하나씩 검사해보는 코드다. 당연히 sample은 CommonFunction 타입이고, 이를 어떻게 ToKorea, ToUSA의 특성을 가져와서 검사를 하는지 보자.반복문 안에 코드를 잘 보면, if let 구문이 있다. 이 조건으로temp = sample as? ToKorea 라고 코드가 들어가있는데, 이는즉, CommonFunction 타입의 sample 변수를 ToKorea 타입으로 다운캐스팅(자식-&gt;부모)하여 성공하면 temp 타입에 대입하도록 한다는 뜻이다.(그럼 암시적으로 temp변수의 타입은 ToKorea 로 지정이 되겠지?)temp: ToKorea? = sample as? ToKorea 로 풀어서 쓸 수 있으며, 이 다운캐스팅이 성공한 이유는, 배열에 들어간 요소의 타입은 CommonFunction(부모클래스) 이지만, 실제로 갖고있는 인스턴스는 ToKorea, ToUSA(자식 클래스) 이기 때문이다.위 코드를 실행해보면,//&lt;결과&gt;// Call in korean// Chal-kak! // Call in English// recording// 한국폰도 잘작동, 미국폰도 잘작동!!따라서, 다운캐스팅이 되는 조건은**부모 클래스의 타입에 자식 클래스의 인스턴스를 대입했고, 그리고 그 부모 클래스 타입의 변수를 ** **이용하여 자식 클래스에 접근하고자 하는게 다운캐스팅이다! **를 설명하기 위해 장황하게 글을 썼다.진짜, 진짜 위에 글을 너무 읽기 싫다면 바로 위에 다운캐스팅 조건으로 강조해놓은 두줄만 읽어도 된다.상속이라는 개념과 as, as?, as! 캐스팅 연산자를 선행해서 알아야 코드 이해에 어려움이 없을 것 같다.장황하게 설명하기 위해서 상속도 조금 다룰까 했지만, 다운캐스팅을 검색한 것 자체가 상속이란 개념을이미 알고있는 상태라 생각하여 생략하였다.다음 포스팅에서는 내가 초보자였을때 힘들었던 또 다른 주제를 가지고 나타나도록 하겠다!메일보내기포스팅에 잘못된 부분이 있거나 궁금하신 점이 있다면, 왼쪽 사이드 하단 메뉴에서 로퍼즈팀으로 메일을 보내주세요!최대한 빠른 시간 내에 회신드릴게요! 감사합니다." }, { "title": "iOS, Swift 문자열에서 인덱스를 정수로, 문자 추출하기!", "url": "/posts/extension-string/", "categories": "Swift, Util", "tags": "swift, util", "date": "2022-10-13 00:25:00 +0000", "snippet": "String을 확장(Extension)해서 C, 자바, 코틀린등과 같이 사용할 수 있다.var greeting = \"Hello, Loperz\"print(greeting[0])extension String { //Character형태로 반환 subscript(_ idx: Int) -&gt; Character { return self[self.index(self.startIndex, offsetBy: idx)] }}//H메일보내기포스팅에 잘못된 부분이 있거나 궁금하신 점이 있다면, 왼쪽 사이드 하단 메뉴에서 로퍼즈팀으로 메일을 보내주세요!최대한 빠른 시간 내에 회신드릴게요! 감사합니다." }, { "title": "효율적인 프로그래밍 기법? 절차지향,객체지향", "url": "/posts/procedural-programming/", "categories": "프로그래밍, 개념", "tags": "프로그래밍, 개념, swift, 이론, 방법론", "date": "2022-10-11 12:15:00 +0000", "snippet": "절차지향과 객체지향 프로그래밍 방식중에 어떤 것이 더 효율적일까?꽤 많은 사람들이 그 차이를 물어보고 종종 논란이 되기도 하는 주제다.하지만 이제 더이상 헷갈리지도, 고민할 필요도 없다.생각보다 더 단순한 이유이기 때문이다.프로그래밍 방법론에는 크게 3가지로 나뉘고 언어 역시 구분된다. 절차지향(절차적) 프로그래밍(Procedural Programming) 객체지향 프로그래밍 (Object-Oriented Programming) 함수형 프로그래밍 (Functional Programming)사실 논란은 대게 이 용어들에 대한 개념이 불분명해서시작되는 것이 아닌가 싶다.그래서 어떤 언어가 더 효율적인거야?절차지향이 객체지향보다 좋은건가?일단 함수형 프로그래밍 방법은 다음 포스팅에서 다루기로 하고,결론부터 말하자면, 절차지향과 객체지향은 그저 프로그래밍 방법론에 불과하다.즉, 프로그램을 만드는데 있어서 어떤 형태(프로그래밍 방식)를 이룰 것인지에 대한 하나의 패러다임이다.절차지향 프로그래밍과 객체지향 프로그래밍에 대해 가볍게 하지만 확실히 알아보자절차지향 프로그래밍(Procedural Programming)절차지향 프로그래밍은 이름에서도 유추할 수 있다.절차가 있는, 순서대로 처리하는 프로그래밍 방식이다.이와 같이 프로그램이 순차적으로 처리되며 각 기능을 모듈화(함수)하고 유기적으로 연결되어 있다.절차지향의 개념은 이게 끝이다.장점과 단점을 살펴보면 아래와 같다.장점절차지향 프로그래밍은 컴퓨터의 작동방식(순차처리)과 비슷하기에, 처리 속도가 빠르다.각 기능이 함수로 만들어져 있어, 어디서든 재사용이 가능하다.또한, 프로그램 전체가 연결되어 있기에, 오류를 추적하기 쉽다단점프로그램 전체가 연결되어 있다는 것은 장점이기도 하지만, 유기적으로 연결되어 있어 유지보수가 쉽지 않다.절차적인 방식이기에 그 순서가 매우 중요해서, 순서가 바뀌면 프로그램 전체가 다운될 수 있다.대표적으로 C, 포트란 등의 언어가 이에 속한다. 하지만 최근들어 C언어등에 해당 기능들이 추가되었기 때문에 객체지향 프로그래밍 역시 가능하다.물론 설계부터 객체지향으로 나온 언어에 비한다면 따라하기 수준에 불과하다.객체지향 프로그래밍(Object Oriented Programming)프로그램을 설계, 구현하는데에 있어서 유지보수까지 생각해야한다. 그런 면에서 유지보수가 힘든 절차지향 프로그래밍 방식을 보완해야할 필요가 있었고, 그로인해 등장한 개념이 바로 객체지향 프로그래밍이다.객체지향 프로그래밍 역시 기본적인 틀은 순차처리다.하지만, 각 구성요소들을 객체로 만들고 각 객체들이 중심이 되어 작동하는 것이 조금 다르다.장점각각의 객체가 독립적으로 실행되기에, 문제가 되는 객체만 수정하면 되므로 유지보수가 쉽다.객체는 하나의 ‘작은 프로그램’이라고 할 수 있어, 프로그램단위의 재사용이 가능하다.단점‘작은 프로그램’을 재사용할 수 있지만, 불필요한 기능까지 전부 가져와야만 할 때도 있다.절차지향보다 복잡해서, 최초 설게 또는 구현에 시간이 상대적으로 오래 걸린다.절차지향에 비해, 상대적으로 처리속도가 느리다.결론C언어등에도 기능이 추가되면서 얼추 객체지향으로 프로그래밍을 할 수 있다.하지만 중요한 것은 절차지향과 객체지향은 서로 대립하는 관계가 아니라는 점이다.소스 코드를 작성하는 방식이 다를 뿐 어떤 것이 더 낫다, 아니다라고 판단할 수는 없다.다만, 현 시점에서 선호되는 방식은 객체지향 프로그래밍이다.메일보내기포스팅에 잘못된 부분이 있거나 궁금하신 점이 있다면, 왼쪽 사이드 하단 메뉴에서 로퍼즈팀으로 메일을 보내주세요!최대한 빠른 시간 내에 회신드릴게요! 감사합니다." }, { "title": "iOS, Swift Date 이해하기 2편", "url": "/posts/understanding-date2/", "categories": "Swift, DeepDive", "tags": "swift, date", "date": "2022-10-10 13:30:00 +0000", "snippet": "iOS, Swift Date 이해하기 1편http://loperz.com/posts/understanding-date/지난 시간에는 Date 타입의 시간이 어디를 기준으로 하는지, 생성자는 어떻게 구성되어 있는지 알아보았다.Date 타입은 시간으로 이루어져 있어 정수형에 그낭 갖다 대입해도 될거같고, 출력되는 포맷 자체가 문자열 처럼도 보여서 아무렇게나 쓸 수 있을것 같아 보이는데, Date도 타입이기 때문에 다른 타입으로변환과정을 거쳐야 잘 사용할 수 있다.Date 타입형을 구워 삶을 수 있는 자료형은1) DateFormatter2) DateComponents두가지가 있다.1) DateFormatterDateFormatter의 설명을 공식문서에서 확인하면 A formatter that converts between dates and their textual representations.번역하면, 날짜와 텍스트 사이를 변환하는 포매터(형식지정자) 역할DateComponents의 설명은A date or time specified in terms of units(such as year, month, day, hour, and minute) to be evaluated in a calendar system and time zone.날짜/시간을 단위별(연, 월, 일, 시간, 분 등)로 지정된 날짜 또는 시간이라고 하는데, 사실 무슨말인지 번역을 봐도 어렵다.이 부분은 아래 적용 코드에서 이해를 돕도록 하겠다.import Foundationlet curruntTime: Date = Date() //GMT +0의 현재시간. 만약 지금이 한국 23시면, -9시. 즉 낮 2시가 뜨겠죠?var dateConvert: DateFormatter = DateFormatter()//DateFormatter 인스턴스 생성print(TimeZone.abbreviationDictionary)//TimeZone.abbreviationDictionary 메서드를 출력하면 각 타임존별 축악여를 전부 확인할 수 있다.//한국은 \"KST\" 인 것 확인 가능!dateConvert.timeZone = TimeZone(abbreviation: \"KST\")//한국 시간 적용. abbrevitation에는 각 날짜 타임존의 축약어가 들어간다.//위에서 설명함!dateConvert.dateFormat = \"yyyy-MM-dd HH:mm:ss\"//dateFormatter 타입의 프로퍼티인 dateFormat을 정해준다.//dateFormate은 날짜를 어떤 방식으로 보여줄 것인지 문자열로 포맷을 정한다.//포맷 방식은 아래 표로 정리해놓았다.let dateString = dateConvert.string(from: curruntTime)//dateConvert에 세팅한 포맷으로 from 인자로 들어간 날짜를 문자열로 반환하는 메서드이다.print(curruntTime)//2022-10-04 14:53:20 +0000 -&gt; Date타입print(dateConvert.string(from: curruntTime))//2022-10-04 23:53:20 -&gt; String타입!물론, Date &lt;-&gt; DateFormatter 를 오갈 수 있도록 메서드도 있으니 공식문서 참고!func date(from string: String) -&gt; Date? : 포맷팅되어 표현된 날짜의 문자열을 Date로 반환! func string(from date: Date) -&gt; String : 날짜를 포맷팅된 문자열로 반환!++ 그리고, DateFormatter에 Locale(identifier: String) 이라는 메서드가 있는데, 여기 들어가는 identifier 인자에 지역 이름 비슷한게 들어가게 되어있다. 여기에 한국 기준으로 “ko_KR” 이라는 축약어가 identifier 인자 로 들어가는데, 저 인자를 넣으면 뭔가 시차가 적용될 것 같은 느낌이 팍팍 드는데, 이는 잘못되었다. (실제로 나도 그랬고 여러 커뮤니티에 Locale 지정했는데 왜 시차적용이 안되요? 하는 글들을 많이 보았다.) 여기에 들어가는 지역별 identifier에 따라 .dateFormat으로 표시했을 때, 각 나라별 방식으로 날짜들이 표현되게 된다. 따라서 Locale은 시차와는 전~~~혀 관련이 없다!ex) 한국: 12월, 미국: Dec… (identifier 축약어는 구글에 Locale identifier list라고 검색하면 잘 정해놓은 글들이 많다.)++코드 설명 추가1) DateComponentsDateComponents는 공식 문서에 의하면*** A date or time specified in terms of units (such as year, month, day, hour, and minute) to be evaluated in a calendar system and time zone.즉, 특정한 날짜/시간의 단위와 관련이 있어 보인다. DateFormatter와 다르게 DateComponents는 생성자만 봐도 뭔가 복잡하게는 되어있는데, 그래도 인자 네임태그가 잘 표현되어 있다.init( calendar: Calendar? = nil, timeZone: TimeZone? = nil, era: Int? = nil, year: Int? = nil, month: Int? = nil, day: Int? = nil, hour: Int? = nil, minute: Int? = nil, second: Int? = nil, nanosecond: Int? = nil, weekday: Int? = nil, weekdayOrdinal: Int? = nil, quarter: Int? = nil, weekOfMonth: Int? = nil, weekOfYear: Int? = nil, yearForWeekOfYear: Int? = nil)위에서 특정한 날짜/시간의 단위와 관련있다고 했는데, 위 코드를 보면 연, 월, 일, 시간, 분, 초 등날짜와 관련된 요소들이 생성자의 인자로 들어가있는데 특이하게도 전부 옵셔널 변수로 들어가 있다.이 말인 즉슨, 모든 인자들이 필수로 들어갈 필요가 없고 원하는 인자만 넣어서 활용할 수 있게되어있는 것 같다. 아래 코드를 보면 이해가 갈 것 이다!//오늘날짜로부터 35일 되는날을 구하는 코드import Foundationlet currentDate = Date() //현재 날짜var calendar = Calendar.current //dateComponents를 활용하기 위한 Calendar 변수calendar.timeZone = TimeZone(abbreviation: \"UTC\")!//Date를 문자열로 처리하기 위한 DateFormatter 변수 선언let dateFormatter = DateFormatter()dateFormatter.dateFormat = \"yyyy-MM-dd HH:mm:ss\"dateFormatter.timeZone = TimeZone(abbreviation: \"UTC\")let day = DateComponents(day: 35)//day: 35일 이라는 요소를 갖도록 인스턴스화. day 변수에는 다른 요소들은 nil이고, 일만 가지고 있다.if let d100 = calendar.date(byAdding: day, to: currentDate){ print(currentDate) // print(dateFormatter.string(from: d100))}//2022-10-10 12:07:35 +0000 -&gt; 현재 시각//2022-11-14 12:07:35 -&gt; 35일 지난 날짜//calendar.date(byAdding: DateComponents, to: Date) 함수를 사용해서//byAdding에 day변수(35일)를, to: 에 현재 날짜를 넣으면//현재 날짜에서 35일 지난 날짜를 d100 변수에 반환시켜 준다.(옵셔널이라 if let 처리!)마치며내가 느끼는 두 자료형의 용도는DateFormatter : Date 를 문자열로 쓰기위한, 혹은 그 반대를 위한 기능을 담당하고,DateComponents : 날짜 데이터 요소(년, 월, 일, 시간 등..)간 계산을 위한 성격이 강하다.DateComponents 자료형에는 별도로 Date나 String으로 반환하는 함수가 없으니반드시 Date나 Calendar에 계산되어 쓴 다음에 DateFormatter로 활용하는 것이 좋다.메일보내기포스팅에 잘못된 부분이 있거나 궁금하신 점이 있다면, 왼쪽 사이드 하단 메뉴에서 로퍼즈팀으로 메일을 보내주세요!최대한 빠른 시간 내에 회신드릴게요! 감사합니다." }, { "title": "iOS, Swift Date 이해하기 1편", "url": "/posts/understanding-date/", "categories": "Swift, DeepDive", "tags": "swift, date", "date": "2022-10-10 12:22:00 +0000", "snippet": "앱을 구현하다가 날짜 관련된 데이터를 다룰 일이 있어서찾아보다가 공부한 내용을 담아보고자 한다.물론 공식 문서만 봐도 이해가 될 만큼 잘 나와있지만, 나같이 성질 급한 사람들을 위해 쓰는 글이고,삽질한 경험을 토대로, 어떻게 삽질을 했는지 경험을 공유하고자 포스팅을 하게 되었다.Date?Date는 날짜 및 시간을 다루는 Swift 의 데이터 형이다. (Int, Double 처럼 구조체로 된 데이터형!)struct DateApple Developer 문서에 따르면A Specific Point in time, independent of any calendar or time zone즉, 날짜나 어떤 위치(즉, 한국인지 미국인지 어디인지)와 전혀 무관한 시간의 특정 지점이 말이 너무 이해가 안갔다. 아니 난 한국에있는데 왜 Date타입으로 날짜를 확인하면 자꾸 전날이 뜨거나시간이 -9시간 되서 뜨는거야? 이 정도는 코드나 운영체제에서 알아서 위치를 확인해서 해주지않나..?아니 그럼 시차는 Date 인스턴스에서 어떻게 적용하는 걸까…? 혼자 엄청나게 고민을 했다.저 설명을 쉽게 표현하자면Date형은 UTC +0기준. 즉 아무런 시차도 적용되지 않은 시간 기준이다!!!어떤 Date 인스턴스가 가지는 날짜/시간은 UTC +0 기준이기 때문에 시차는 아예 적용되어 있지 않다.(검색해보니 UTC와 GMT 는 거의 비슷하게 통용된다고 한다.(GMT는 그리니치 천문대 표준시))Date의 요소Date가 가지는 주요 요소를 보면1) 연도2) 월3) 일4) 시간5) 분6) 초7) 밀리초8) 요일정도가 가장 많이 쓰일 것 같다.(물론 다른 요소들도 많은거 같다… 주차, 분기, 등..)기본적으로 날짜/시간 관련되서는 전부 가지고 있다.Date 생성자!위에서 설명했듯이, Date 객체 자체는 UTC 기준의 시간만을 가지는 것만 알면 헷갈리지 않고사용할 수 있을것이다.Date 타입도 구조체기 때문에 생성자를 갖는다. Date는 어떤 생성자를 가지고 어떻게 속성들을 가지게 되는지 알아보자.1) init()그냥 Date()로 생성시키면 생성되는 현재 시각이 표시된다.(뒤에 +0000에서 UTC 기준 시간임을 알 수 있다.)let currentDate: Date = Date()//2022-09-19 12:47:30 +0000 2) init(timeIntervalSinceNow: TimeInterval)TimeInterval 파라메터의 타입은 정수형(Int)인데, 현재 시간에서 TimeInterval 초 만큼 지난 시간이 세팅된다. 아래 코드를 보면 현재 시간은 12:50:00인데, 30을 부여하면 12:50:30으로 표시된다.let currentDate: Date = Date()print(currentDate)//2022-09-19 12:50:00 +0000let date2: Date = Date(timeIntervalSinceNow: 30)print(date2)//2022-09-19 12:50:30 +00003) init(timeInterval: TimeInterval, since: Date)since 파라메터에 Date 요소가 들어가게 되어있다. 즉, 파라메터로 들어간 Date 시간으로 부터 TimeInterval 에 세팅된 초 만큼 지난 시간을 객체에 가진다. 아래 코드를 보면 현재시간 + 30초된 시간이 date2 변수에 저장되어 12:56:15가 세팅되었고,date3에 since에 세팅된 date2 기준에서 43초 흐른 시간이 세팅되어 있다.let date2: Date = Date(timeIntervalSinceNow: 30)print(date2)//2022-09-19 12:56:15 +0000let date3: Date = Date(timeInterval: 43, since: date2)print(date3)//2022-09-19 12:56:58 +00004) init(timeIntervalSinceReferenceDate: TimeInterval)2001년 1월 1일 0시부터 TimeInterval 초 만큼 흐른 시간이 세팅된다.let date4: Date = Date(timeIntervalSinceReferenceDate: 45)print(date4)//2001-01-01 00:00:45 +00005) init(timeIntervalSince1970: TimeInterval)1970년 1월 1일 0시부터 TimeInterval 초 만큼 흐른 시간이 세팅된다.아래 코드에서는 1970년 1월 1일 0시0분0초부터 5초가 흐른 시간이 세팅되었다.let date5: Date = Date(timeIntervalSince1970: 5)print(date5)//1970-01-01 00:00:05 +0000Date 타입의 생성자에 따라서 어떻게 날짜/시간 속성을 가지는지 알아보았다. Date타입도 구조체기 때문에 Date 인스턴스 간 비교 연산도 가능하다.깨알팁) 레퍼런스 문서에 func == (lhs: Date, rhs:Date), func &gt; (lhs: Date, rhs:Date) 로 표시되어 있는메서드들은 인스턴스간 비교연산자로 Bool연산이 가능하다는 뜻이다.(물론 +, - 같은 계산도!)다음 포스팅에서는 이 Date 타입을 어떻게 구워삶는지 알아보자.메일보내기포스팅에 잘못된 부분이 있거나 궁금하신 점이 있다면, 왼쪽 사이드 하단 메뉴에서 로퍼즈팀으로 메일을 보내주세요!최대한 빠른 시간 내에 회신드릴게요! 감사합니다." }, { "title": "iOS 뷰의 특정 부분에 테두리 그리기!", "url": "/posts/draw-bottom-line/", "categories": "iOS, Guide", "tags": "ios, guide", "date": "2022-09-30 12:25:00 +0000", "snippet": "스토리보드 또는 SwiftUI로 View를 그리다보면 종종 테두리가 필요할 때가 있다.전체 테두리 그리기대게는 이렇게 전체 테두리를 그린다.이미 알고 있겠지만, 코드는 이렇다.self.cameraBtn.layer.borderColor = UIColor.black.cgColorself.cameraBtn.layer.borderWidth = 1.0self.cameraBtn.layer.cornerRadius = 10self.cameraBtn.layer.masksToBounds = true부분 테두리 그리기하지만 가~끔은 위아래 혹은 좌우 혹은 한쪽만 라인을 그리고 싶을 때가 있다.Layer를 확장(Extension)해주면 된다.extension CALayer { func drawLineAt(edges:[UIRectEdge], color: UIColor, width: CGFloat) { for edge in edges { let border = CALayer() switch edge { case UIRectEdge.top: border.frame = CGRect.init( x: 0, y: 0, width: bounds.width, height: width ) case UIRectEdge.bottom: border.frame = CGRect.init( x: 0, y: frame.height-width, width: bounds.width, height: width ) case UIRectEdge.left: border.frame = CGRect.init( x: 0, y: 0, width: width, height: bounds.height ) case UIRectEdge.right: border.frame = CGRect.init( x: frame.width-width, y: 0, width: width, height: bounds.height ) default: break } border.backgroundColor = color.cgColor self.addSublayer(border) } }}사용 예시TextView, TextField, Label을 만들어 각각 Top, left/right, bottom을 줬다.테두리를 그리고 싶은 부분을 배열로 전달하면 간단하다.//textView의 위쪽에만 빨간색으로 테두리를 그린다.func drawLineAtTopOfTextView() { self.textView.layer.drawLineAt( edges: [.top], color: UIColor.red, width: 5.0 )}//textField의 왼쪽과 오른쪽에 갈색으로 테두리를 그린다. func drawLineAtLeftAndRightOfTextField() { self.textField.layer.drawLineAt( edges: [.left, .right], color: UIColor.brown, width: 5.0 )} //label의 아래쪽만 테두리 그리기func drawLineAtBottomOfLabel() { self.label.layer.drawLineAt( edges: [.bottom], color: UIColor.black, width: 5.0 )}UIRectEdge는, .all .top .bottom .left .right총 다섯개의 상태값을 가지고 있다.결과아래와 같이 지정된 부분에 테두리가 그려지는 것을 확인할 수 있다.메일보내기포스팅에 잘못된 부분이 있거나 궁금하신 점이 있다면, 왼쪽 사이드 하단 메뉴에서 로퍼즈팀으로 메일을 보내주세요!최대한 빠른 시간 내에 회신드릴게요! 감사합니다." }, { "title": "Swift 값의 일치 여부를 판단하는 Switch문 이해하기", "url": "/posts/swift-grammer-switch/", "categories": "Swift, Grammer", "tags": "swift, grammer, 조건문", "date": "2022-09-27 12:47:00 +0000", "snippet": "Swift는 참과 거짓을 판별하는 조건문 혹은 분기문을 2가지 제공한다.If - else if - else문(이하 if문)과 Switch - case문(이하 switch문)이다.If - else if - else문은 아래 링크에서 확인할 수 있다.https://lastloper.github.io/posts/swift-basic-if/개념if문이 문에 맞는 키를 찾아 문을 여는 방식이라면,Switch문은 마치 다양한 보기중에 하나를 선택하는 객관식 문제와 비슷하다.주어진 보기(case문)중에서 일치하는 case의 구문을 실행하는 것이다. 사용방법은 간단하다.사용법기본기본적인 사용방법이다. 다른 언어들과 크게 다르지 않은 모양인데, Swift는 기본적으로 내용이 있을때는 break를 써주지 않아도 된다.var color = \"Purple\"switch color {case \"Green\", \"Red\", \"Blue\": //각각 나열할 수 있지만 ,(쉼표)를 사용해서 하나로 처리할 수도 있다. print(\"빛의 삼원색에 포함됩니다.\")default: print(\"빛의 삼원색에 포함되지 않습니다.\")}//빛의 삼원색에 포함되지 않습니다.범위연산자범위연산자를 case로 줄 수 있다. Range 또는 ClosedRange 모두 사용 가능하다.var myMoney = 1000...5000switch myMoney {case 100...999: print(\"현재 물가로 육개장 사발면도 못사요!\")case 1000...5000: print(\"다이소 물건을 살 수 있어요!\")case 5000...15000: print(\"한 끼 식사를 할 수 있어요!\")case 15000...50000: print(\"영화는 못보지만 둘이 술 한잔 할 수 있어요!\")default: print(\"하고 싶은 걸 다 할 수 있어요~!\")}//다이소 물건을 살 수 있어요!튜플튜플은 잘 알다시피 다양한 타입의 값을 가지는 변수 또는 상수를 말한다.아래와 같이 team으로 정의된 상수가 바로 튜플이다.let team:(String, Int) = (\"Loperz\", 2)let (teamName, countOfMember) = teamprint(\"팀명 : \\(teamName), 멤버수 : \\(countOfMember)명\")//팀명 : Loperz, 멤버수 : 2명이제 이 튜플을 조건으로 Switch문에서 값을 매칭할 수 있으며,case문내에서만 사용할 수 있는 상수를 만들어 값을 바인딩해서 사용할 수 있다.switch team {case (let name, 0..&lt;1000): print(\"\\(name)은 새내기 개발팀입니다.\")case (\"Loperz\", 100000..&lt;60000000000): print(\"Loperz의 멤버는 전세계 개발자들과 함께합니다.\")default: print(\"Loperz는 열심히 성장하고 있는 중입니다.\") break}//Loperz은 새내기 개발팀입니다.알아두면 쓸데있는 개발팁 Switch문의 각 case에는 반드시 break, fallthrough 또는 내용이 있어야 한다. 모든 case를 작성하지 않는다면 default를 작성해 줘야한다. Switch문 case를 처리한 후 자동으로 빠져나오지만 아래 case까지 실행하고 싶을 때, fallthrough를 작성해주면 된다.위 예제에서 범위를 case로 했을 때 각 case의 조건이 겹치는 것을 발견할 수 있다. 이때 fallthrough 명령어를 입력해주면 해당하는 모든 case구문을 처리한다. case 1000...5000: print(\"다이소 물건을 살 수 있어요!\") fallthrough //멈추지 않고 조건과 일치하는 아래 구문까지 실행하도록 한다.case 5000...15000: print(\"한 끼 식사를 할 수 있어요!\") . . .}//다이소 물건을 살 수 있어요!//한 끼 식사를 할 수 있어요!퀴즈이제 막 Swift를 시작한 프로그래밍 초보인 분들을 위한 퀴즈입니다. 정답을 직접 코딩해서 저희 로퍼즈 메일로 보내주세요!메일 주소는 왼쪽 사이드 메뉴의 하단 메일 버튼을 이용해주세요, 바로 메일을 보낼 수 있답니다.//a와 b는 아래와 같이 돈을 가지고 있습니다.let money:(Int, Int) = (3000, 1000)let (aMoney, bMoney) = money//이때 switch문을 이용해서 둘이 같은 금액을 가지고 있는지 아닌지 출력해보세요.//같은 금액이라면 \"a와 b가 가진 돈은 같습니다.\"//다른 금액이라면 \"a는 3000원, b는 1000원의 돈을 가지고 있습니다.\"//hint. Switch문은 where명령어를 사용해서 값을 조금 더 정밀하게 비교할 수 있다.메일보내기포스팅에 잘못된 부분이 있거나 궁금하신 점이 있다면, 왼쪽 사이드 하단 메뉴에서 로퍼즈팀으로 메일을 보내주세요!최대한 빠른 시간 내에 회신드릴게요! 감사합니다." }, { "title": "iOS앱 카메라 사용 권한 요청 쉽고 깔끔하게 하기", "url": "/posts/permission-of-camera/", "categories": "iOS, Guide", "tags": "ios, guide, camera, photo, media", "date": "2022-09-20 01:31:00 +0000", "snippet": "애플은 아이폰 등 기기가 카메라, 앨범등에 접근하기 위해서 사용자의 동의를 얻도록 강제하고 있습니다. 이유는 간단합니다. 카메라나 앨범이 개인정보에 포함될 수 있기 때문이지요. 그래서 앱 또는 시스템에서 함부로 쓸 수 없도록 강제하고 있는데요, 때문에 개발자는 사용할 수 있는 권한을 달라고 사용자에게 요청합니다.이때 애플은 기능을 사용하기 바로 직전에 요청하도록 권장하고 있어요.가끔 앱 시작과 동시에 수많은 권한을 요청하는 것이 리젝트되는 사유가 되기도 하거든요. 그러니 가급적 해당 기능을 사용하려 할 때 요청하도록 하는게 좋겠죠?info.plist에 필요한 권한 설정어떤 권한이든 가장 먼저 해줘야 할 작업입니다. 바로 info.plist에서 요청시 전달할 메세지를 작성하는 것인데요, 카메라 권한은 아래와 같이 Privacy - Camera Usage Description을 추가해서 메세지를 작성해주세요.info.plist에서 권한 요청 메세지 작성하기그리고 이제 ViewController로 돌아와 viewDidLoad() 또는 버튼 이벤트등 기능이 작동하기 직전에 아래 코드로 사용자에게 권한을 요청하고 응답에 대한 처리를 할 수 있습니다.enum AVAuthorizationStatus의 Int형 상태값을 리턴합니다.switch AVCaptureDevice.authorizationStatus(for: .video) { case .authorized: //요청 허가되었을 때 //TO DO break case .denied: //요청 거부되었을 때 //TO Do break case .restricted: //권한이 필요한 장치를 찾을 수 없는 상태 break case .notDetermined: //아직 어떤 응답도 없는 상태 break}기본적으로 4가지 응답에 대한 처리를 할 수 있지만, 사실상 3가지 경우에 대해서만 처리해도 무방합니다.switch AVCaptureDevice.authorizationStatus(for: .video) { case .authorized: //요청 허가되었을 때 TO DO break case .notDetermined: //아직 응답이 없을 때 TO DO break default: //요청이 거부되었을 때 //.denied와 .restricted 두 상태 모두 권한 없음으로 처리할 수 있다. break}권한을 요청하는 것은 이것으로 끝입니다!하지만, 사용자가 권한을 허락하지 않았다면 재요청하는 과정이 반드시 있어야 하겠죠?거부시 재요청하기보통 카메라를 사용하기 위해 버튼을 눌렀을 때 권한을 요청하곤 합니다.이때 사용자가 실수로 ‘거부’를 눌렀다면 어떻게 다시 권한을 요청해야 할까요? 버튼을 눌렀을 때 다시 요청한다. 아이폰의 [설정]으로 이동해서 권한을 수정할 수 있도록 유도한다.대충 이정도 방법이 떠오르는데요, 보통 2번째 방법을 가장 많이 쓰고 개인적으로도 추천하는 방법입니다.이를 위한 샘플코드로는 애플 AVCam프로젝트를 보는 것을 추천드려요. 다른 예시 필요없이 가장 깔끔한 코드가 아닌가 싶네요. AVCam프로젝트는 권한 요청과 확인, 거부시 재요청까지 구현되어 있습니다.한번 만들어 볼까요?어렵지 않으니 천천히 따라오세요~일단 아래와 같이 권한 상태에 대한 플래그 변수와 쓰레드를 만들어주세요.private let sessionQueue = DispatchQueue(label: \"session queue\")private var setupResult: SessionSetupResult = .successenum SessionSetupResult { case success case notAuthorized case configurationFailed}상황에 따라 다르겠지만, 만약 앱이 처음부터 카메라 사용을 필요로 한다면 viewDidLoad()에서 아래와 같이 요청할 수 있습니다.func viewDidLoad() { . . . switch AVCaptureDevice.authorizationStatus(for: .video) { case .authorized: //setUpResult의 초기값이 .success로 되어 있기 때문에 //권한이 부여된 상태에서는 별다른 처리를 할 필요가 없습니다. break case .notDetermined: //응답이 아직 없는 상태라면, //일단 카메라 설정등을 위한 쓰레드를 멈추고 //권한을 재요청 후 권한을 받았을 때, 쓰레드를 다시 작동시킨다. sessionQueue.suspend() AVCaptureDevice.requestAccess(for: .video, completionHandler: { granted in if !granted { //setUpResult에 아직 거부된 상태임을 저장한다. self.setupResult = .notAuthorized } self.sessionQueue.resume() }) default: //setupResult에 거부된 상태임을 저장한다. setupResult = .notAuthorized } sessionQueue.async { //쓰레드가 작동중인 상태라면 //CaptureSession등을 이때 설정한다. }}그리고 viewWillAppear()에서 상태값 확인 후 그에 따른 로직을 구현하시면 됩니다.//viewWillAppear()sessionQueue.async { switch self.setupResult { case .success: //승인된 상태 //카메라를 실행합니다. case .notAuthorized: //거부된 상태 DispatchQueue.main.async { //Alert를 띄워 메세지를 보여주고, //UIApplication.shared.open(URL(string: UIApplication.openSettingsURLString)! //위 함수를 호출해서 아이폰의 환경설정으로 연결해서 권한을 부여할 수 있습니다. } case .configurationFailed: //상태가 .restricted 등일 때의 오류가 발생한 경우에 대한 처리를 합니다. DispatchQueue.main.async { //에러 Alert를 띄워 사용자에게 알립니다. } }}더 자세한 내용을 보고 싶다면 아래 애플 개발자 사이트를 참고해주세요!카메라에 대한 샘플코드 또한 있으니 훑어보시면 좋습니다.https://developer.apple.com/documentation/avfoundation/capture_setup/avcam_building_a_camera_app그럼, It’s coding time~!메일보내기포스팅에 잘못된 부분이 있거나 궁금하신 점이 있다면, 왼쪽 사이드 하단 메뉴에서 로퍼즈팀으로 메일을 보내주세요!최대한 빠른 시간 내에 회신드릴게요! 감사합니다." }, { "title": "iOS 스크롤뷰 오토레이아웃 한방에 잡는 간단한 방법", "url": "/posts/scrollview-auto-layout/", "categories": "iOS, Guide", "tags": "ios, guide", "date": "2022-09-18 09:19:00 +0000", "snippet": "스크롤뷰는 오토레이아웃을 잡을 때마다 헷갈려서 순서를 정리했다.스크롤뷰 오토레이이아웃역시 가장 먼저 할 일은 뷰컨트롤러에 스크롤뷰를 배치하는 것이다. 그럼 왼쪽 파일구조에서 스크롤뷰 밑으로 Content Layout Guide와 Frame Layout Guide가 생기는 것을 볼 수 있는데, 사실 이것때문에 매번 헷갈리지 않았나 싶다.스토리보드에 스크롤뷰 배치하기그래서 찾아보니 일반적인 스크롤뷰를 만들때는 굳이 필요없다는 것을 확인했다.왼쪽 인스펙터에서 Gontents Layout Guide 체크박스를 해제하자, 한결 쉬워진다.Contents Layout Guide 체크 해제하기그럼 체크박스를 해제하면 스크롤뷰의 파일구조가 바뀌는 것을 확인할 수 있는데, 이제 컨텐츠뷰가 될 UIView를 스크롤뷰에 넣어서 본격적으로 오토레이아웃을 잡아보자.컨텐츠뷰 오토레이아웃1. 상하좌우 Spacing은 스크롤뷰와 꼭 맞게사진과 같이 View의 Top, Trailing, Bottom, Leading 모두 스크롤뷰에 맞춘다. 모든 Spacing이 0임에도 불구하고 View의 크기가 늘어나지 않는 이유는 스크롤뷰의 크기가 아직 정해지지 않았기 때문인데, 이를 위해서 View의 크기가 먼저 확실해져야 한다.스크롤뷰의 컨텐츠뷰 배치Spacing을 0으로 맞추고 늘어나지 않은 View의 크기는 마우스로 직접 드래그해서 넓혀준다.스크롤뷰의 컨텐츠뷰 오토레이아웃2. 가로길이는 스크롤뷰와 똑같이View의 가로길이와 세로길이를 이제 정해줘야 하는데, 먼저 가로길이를 스크롤뷰와 같게 정해준다.이때 컨텐츠뷰 width값의 Multiplier를 보면 1이 아니다. 그래서 아래와 같이 꽉차게 보이지 않는다.Multiplier가 1이 아닌 상태Multiplier를 1로 맞춰서 꽉채워주자.Multiplier를 1로 설정3. 늘어날 세로길이의 Priority는 낮게이제 세로길이만 잡아주면 되는데, 세로길이의 경우 안에 들어가는 컨텐츠 양에 따라 그 높이가 바뀐다. 그래서 스크롤되는 것이다. 이를 위해 높이가 상황에 맞게 유동적으로 바뀔 수 있도록 우선순위를 낮춰주면 된다.먼저 화면을 꽉채운 View의 높이를 아래와 같이 그대로 잡아준다.높이 설정그리고 높이의 priority값을 250으로 낮춘다.높이 우선순위 조절이제 컨텐츠뷰에 버튼이나 이미지뷰등을 배치해서 확인해보면 잘 작동하는 것을 볼 수 있다.It’s coding time~~메일보내기포스팅에 잘못된 부분이 있거나 궁금하신 점이 있다면, 왼쪽 사이드 하단 메뉴에서 로퍼즈팀으로 메일을 보내주세요!최대한 빠른 시간 내에 회신드릴게요! 감사합니다." }, { "title": "Swift iOS 뷰 또는 이미지 뷰에 터치 이벤트 주기!", "url": "/posts/imageview-gesture/", "categories": "iOS, Guide", "tags": "ios, guide", "date": "2022-09-15 10:42:00 +0000", "snippet": "Button은 IBAction을 직접연결해서 터치 이벤트를 처리할 수가 있다.그럼, UIView는? ImageView는? Label은?우린 종종 View 또는 ImageView, Label 등에서도 터치 이벤트를 처리해야할 때가 있다.간단하게 제스처(Gesture)를 연결해주면 된다.뷰에 TapGestureRecogniger 연결하기각각 UIView, UIImageView, UILabel에 연결을 해볼텐데, ImageView와 Label은 조금 다른 점이 있으니 잘 살펴 보자.//탭 제스처를 만든다.let gesture = UITapGestureRecognizer( target: self, action: #selector(self.viewTapped(_:)) )이 제스처는 action파라미터인 #selector로 선언된 함수를 호출하며, 이 함수는 Objective-C의 형태로 만들어져야 한다.@objc 어노테이션을 함수 앞에 붙여주면 Objective-C 타입의 함수로 만들 수 있다.@objcprivate func viewTapped(_ sender: UITapGestureRecognizer) { self.updateUI(text: \"뷰가 눌렸습니다!\")}@objc는 Swift가 나오기 전 애플 공식 개발 언어였던 Objective-C코드를 Swift에서 사용하기 위해 만들어진 어노테이션이다.다시말해, UITapGestureRecognizer()는 Objective-C 형태의 함수 코드를 필요로 하는데, Swift코드에서도 쓸 수 있도록 붙여주는 것이라고 생각하면 된다!이 제스처가 어떤 동작을 할 것인지 함수까지 만들었다면, 이제 아래와 같이 뷰에 연결만 해주면 된다.//뷰에 제스처를 연결한다.self.uiView.addGestureRecognizer(gesture)isUserInteractiveEnabled 설정하기ImageView 또는 Label 역시 이와 같은 작업을 해주면 되는데, UIView와는 다르게 한가지 작업이 더 필요하다.let gestureForLabel = UITapGestureRecognizer( target: self, action: #selector(self.labelTapped(_:)) )self.label.isUserInteractionEnabled = true //바로 이것!self.label.addGestureRecognizer(gestureForLabel)UIView는 기본적으로 사용자와 상호작용할 수 있도록 isUserInteractiveEnabled가 true로 설정되어 있다.하지만, ImageView와 Label은 false가 기본값이다. 따라서 true로 바꾸어 줘야 한다.물론 아래와 같이 스토리보드에서도 설정할 수 있다.스토리보드에서 isUserInteractiveEnabled설정메일보내기포스팅에 잘못된 부분이 있거나 궁금하신 점이 있다면, 왼쪽 사이드 하단 메뉴에서 로퍼즈팀으로 메일을 보내주세요!최대한 빠른 시간 내에 회신드릴게요! 감사합니다." }, { "title": "iOS 스토리보드에서 스크롤뷰 전체를 보고 싶을때", "url": "/posts/show-full-scrollview/", "categories": "iOS, Guide", "tags": "ios, guide", "date": "2022-09-13 10:52:00 +0000", "snippet": "SwiftUI가 아닌 Storyboard를 이용한다면, 이렇게 스크롤뷰를 배치할 때가 있다.그런데 가끔은, 배치하는 뷰들이 Storyboard의 기기 사이즈를 넘을 때도 있다. 바로 이렇게.스크롤뷰 셋팅이럴 때, 마우스 휠을 움직여 뷰를 위아래로 움직일 수 있다. 하지만, 조금 뿐이다. 그것도 아주 조금.다행스럽게도 전체 뷰를 Storyboard에서 볼 수 있는 방법이 있다.그 방법도 아주 간단하다.Size Inspector에서 옵션 바꾸기Size Inspector에서 옵션 바꾸기뷰 컨트롤러를 선택 후, Size Inspector에서 Simulated Size를 Fixed에서 Freeform으로 바꿔주면된다.그럼 Storyboard에서 뷰 컨트롤러의 모양이 바뀐 것을 확인할 수 있는데,아래쪽을 마우스로 잡아끌면 상하 또는 좌우 크기를 조절할 수 있다.늘어난 뷰 컨트롤러이제 다시, It’s coding time~~~메일보내기포스팅에 잘못된 부분이 있거나 궁금하신 점이 있다면, 왼쪽 사이드 하단 메뉴에서 로퍼즈팀으로 메일을 보내주세요!최대한 빠른 시간 내에 회신드릴게요! 감사합니다." }, { "title": "iOS 스위프트 GCD, DispatchQueue 쉽게 이해하기", "url": "/posts/dispatch-queue/", "categories": "Swift, DeepDive", "tags": "swift, gcd", "date": "2022-09-04 09:48:00 +0000", "snippet": "쓰레드는 조금 무거운 주제라 지겨울 수도 있겠지만, 별 수 있을까그래도 한 번 잘 읽고, 정리하면 스레드가 조금 더 가까워질 것이라 확신한다.GCD?Grand Central Dispatch쉽게 말해 스위프트에서 Queue를 관리하는 API다.즉, 메인 스레드 또는 백그라운드 스레드를 관리하는 것. 애플에서도 DispatchQueue를 아래와 같이 정의하고 있다.An object that manages the execution of tasks serially or concurrently on your app’s main thread or on a background thread.앱의 메인 스레드 또는 백그라운드 스레드에서 순처적인 작업 혹은 병렬적 작업들을 관리하는 객체DispatchQueue.main //UI를 담당하는 메인 스레드DisaptchQueue.global() //백그라운드에서의 작업을 담당하는 스레드사용법은 단 두가지밖에 없어서 딱히 어려운 것은 없다. 비동기 처리를 위해서는 DispatchQueue.global()만 써주면 되니까. 하지만 난 효율의 민족이니까 효율적으로 잘~ 쓰기 위해서 조금 더 공부했다.DispatchQueue.global() 사용법DispatchQueue.main는 사용자와의 상호작을 위한 UI스레드로써, 메인 스레드라고도 불리며 UI가 Lock이 걸리는 일이 발생하면 안된다. 그래서 다운로드 같은 네트워크 통신은 Xcode에서도 웬만하면 DispatchQueue.global()에서만 하도록 반쯤 강제한다.또한 대부분의 경우 DispatchQueue.global()을 훨씬 더 많이 쓰기 때문에 이에 대한 내용을 위주로 써보려고 한다.Sync와 Async, 동기와 비동기//'.sync'와 '.async'로 구분해서 사용할 수 있다.//'동기 처리', '비동기 처리'가 바로 이것이다.DispatchQueue.global().sync { /* task */ }DisaptchQueue.global().async { /* tasks */ }이제 작업을 백그라운드 스레드로 넘겨서 실행하기 때문에 메인 스레드에는 아무런 영항이 없다. 온전히 다른 스레드에서 별개의 동작을 하는 것이다. 하지만! 백그라운드 스레드에서도 응답을 주고 받으면서 작업할 것인지, 아니면 응답과는 상관없이 독립적으로 작업할 것인지를 구분해야 한다.이번 포스팅에서는 조금 더 많이 쓰는 .async(비동기 처리)를 조금 더 자세하게 정리했다..Async 예제DispatchQueue.global().async { sleep(2) print(\"백그라운드에서 실행됩니다.\")}print(\"메인스레드의 작업이 실행됩니다.\")//결과메인스레드의 작업이 실행됩니다.백그라운드에서 실행됩니다.DispatchQueue.global()로 넘어간 작업은 메인 스레드에 아무런 영향을 주지 않고, .async가 사용되었기에 비동기적으로 처리된다. 따라서 메인 스레드에 있는 print() 구문이 먼저 출력되고, 백그라운드 스레드로 넘어간 print() 구문이 출력되는 것을 볼 수 있다.하지만 이는 sleep(2)라는 딜레이로 인해 늦게 메인 스레드보다 늦게 출력된 것이지, 항상 백그라운드 스레드가 늦게 끝난다는 보장은 없다. 만약 백그라운드 스레드로 넘어간 작업이 먼저 끝났다면, 메인 스레드보다 먼저 실행될 수 있다.Sleep()함수가 없는 아래 코드를 실행하면 백그라운드 스레드의 print() 구문이 먼저 실행되는 것을 볼 수 있다.DispatchQueue.global().async { print(\"백그라운드에서 실행됩니다.\")}print(\"메인스레드의 작업이 실행됩니다.\")//결과백그라운드에서 실행됩니다.메인스레드의 작업이 실행됩니다.QOS라는 것도 있던데?DispatchQueue.global()을 쓸 때, 한 가지 생각해야 할 부분이 있다. 바로 QOS(Quality-Of-Service)다. 말 그대로 백그라운드에서 작업할 때 얼마나 중요한 작업인지를 시스템에 알려주는 것으로 생각하면 된다.QOS 값으로는 enum class로 정의되어 있다. 상황에 맞는 파라미터를 써주자 userInteractive userInitiated default utility background unspecified하나씩 살펴보자1. userInteractive애니메이션이나 어떤 이벤트로 인해 UI를 업데이트 하고 싶다면, 이 값으로 즉각적인 응답을 요청할 수 있다.2. userInitiated어떤 이미지를 받아와서 보여줘야 하는데, 시간이 걸린다면 이 값으로 요청하고 로딩 애니메이션을 보여줄 수 있다.다시 말하자면, 빠른 응답을 요구하면서도 사용자를 기다리게 만드는 요소인 것이다.3. defaultqos 파라미터를 넣어주지 않으면 동작하는 가장 기본적인 우선순위다.4. utility사용자가 제어할 수 없는 우선순위이며, 응답이 없어도 앱 사용에는 아무런 지장이 없는 요청 값이다.5. background제일 낮은 우선순위로써, 앱이 백그라운드 상태에 있을 때 동작한다.6. unspecifiedDocument에는 정의되어 있지만 실제로는 쓰지 않는다.백그라운드 스레드 종료 시점종종 네트워크 작업이 필요할 때, 각기 다른 API를 사용해야 할 때가 있다. 그리고 그 모든 작업이 끝나야지만 UI를 업데이트 해야하는 경우가 있다. 이때 개발자는 백그라운드 스레드의 종료 시점을 어떻게 알 수 있을까?간단하게 DispatchGroup()을 써주면 된다.스레드가 모두 종료되기까지 기다려야 하는 Wait()let queue = DispatchQueue.global()let group = DispatchGroup()queue.async(group: group) { sleep(3) print(\"작업 1\")}queue.async(group: group) { sleep(5) print(\"작업 2\")}group.wait()print(\"모든 작업이 완료되었습니다.\")print(\"메인 스레드를 시작합니다.\")//결과작업 1작업 2모든 작업이 완료되었습니다.메인 스레드를 시작합니다.위 예제와 같이 wait()을 써주면 백그라운드 스레드의 종료시점을 알 수 있다.하지만 결과에서 볼 수 있듯이 메인 스레드 작업이 가장 늦게 끝난다. 다시 말해, 백그라운드 스레드 작업이 종료되는 시점까지 Rock을 거는 것이다.스레드가 종료되는 시점을 알려주는 Notify()group.enter()queue.async(group: group) { sleep(3) print(\"작업 1\") group.leave()}group.enter()queue.async(group: group) { sleep(5) print(\"작업 2\") group.leave()}group.notify(queue: queue) { DispatchQueue.main.async { //UI 작업 } print(\"모든 작업이 완료되었습니다.\")}print(\"메인 스레드를 시작합니다.\")//결과메인 스레드를 시작합니다.작업 1작업 2모든 작업이 완료되었습니다.Notify()를 사용하면, 이제야 비로소 백그라운드 스레드다운 모습을 보여주면서도 종료 시점까지 확인할 수 있다.메일보내기포스팅에 잘못된 부분이 있거나 궁금하신 점이 있다면, 왼쪽 사이드 하단 메뉴에서 로퍼즈팀으로 메일을 보내주세요!최대한 빠른 시간 내에 회신드릴게요! 감사합니다." }, { "title": "iOS 버튼 이미지 위치 바꾸기", "url": "/posts/force-to-left-right/", "categories": "iOS, Guide", "tags": "ios, guide", "date": "2022-06-26 13:55:00 +0000", "snippet": "버튼에 이미지를 넣었다면 이미지는 기본적으로 왼쪽에 위치하게 된다.버튼 이미지 기본 위치그 위치를 Inspectors에서 바꿀 수 있다.이미지 위치를 조절할 수 있는 SemanticInspectors - View - Semantic 에서 타이틀과 이미지의 위치를 왼쪽 또는 오른쪽으로 지정할 수 있다.메일보내기포스팅에 잘못된 부분이 있거나 궁금하신 점이 있다면, 왼쪽 사이드 하단 메뉴에서 로퍼즈팀으로 메일을 보내주세요!최대한 빠른 시간 내에 회신드릴게요! 감사합니다." }, { "title": "Class, IBOutlet명까지 변수명 한번에 바꾸는 방법 in Xcode", "url": "/posts/change-names-at-once/", "categories": "iOS, Xcode", "tags": "ios, xcode, tips, swift", "date": "2022-06-26 13:07:00 +0000", "snippet": "XCode의 찾기-바꾸기의 기능은 해당 페이지의 모든 동일한 이름을 바꾸지만, 이는 방법은 변수명 뿐만 아니라 클래스명과 IBOutlet명까지 한번에 바꾸는 방법이다.아래 이미지와 같이 변수명을 [우클릭] - [Refactor] - [Rename] 한다.Class명이나 IBOutlet명도 동일하게 바꿀 수 있다.rename 메뉴이후 XCode는 패키지의 모든 파일을 검색한다. 그래서 시간이 조금 걸릴 수 있다.rename 결과바꾸려는 모든 같은 이름을 찾은 결과를 보여주면, 이름을 바꾸고 엔터↵를 치면 전부 바뀐 것을 확인할 수 있다.단축키가 없는게 좀 아쉽지만..메일보내기포스팅에 잘못된 부분이 있거나 궁금하신 점이 있다면, 왼쪽 사이드 하단 메뉴에서 로퍼즈팀으로 메일을 보내주세요!최대한 빠른 시간 내에 회신드릴게요! 감사합니다." }, { "title": "Swift 참과 거짓을 구분하는 If문 이해하기", "url": "/posts/swift-grammer-if/", "categories": "Swift, Grammer", "tags": "swift, grammer", "date": "2022-06-24 04:15:00 +0000", "snippet": "개요이름부터 아주 직관적인, 주어진 값이 참인지 거짓인지를 판별하는 조건문이다.사용법 또한 간단하다.도식화if문 도식화사용법//기본적인 형태로써, 참과 거짓을 판별한다.var isOn = trueif isOn { print(\"전원이 켜졌습니다.\")} else { print(\"전원이 꺼졌습니다\")}// =&gt; 전원이 켜졌습니다.//변수와 상수, 변수와 변수를 == 연산자로 비교할 수 있다.var isTen = 9let eleven = 11if isTen == 9 { print(\"9입니다.\")} else if isTen == eleven { print(\"11입니다.\")} else { print(\"10인지 모르겠어요.\")}// =&gt; 10인지 모르겠어요//문자열 역시 == 로 비교할 수 있다.var food = \"삼겹살\"If food == \"삼겹살\" { print(\"소주 한 병 주세요~\")} else if food == \"치킨\" { print(\"시원한 맥주 주세요~\")} else { print(\"사이다 주세요~\")}// =&gt; 소주 한 병 주세요~Tip. 실무에 많이 쓰이는 방법대게 If - else if - else의 기본 형태를 가장 많이 쓰지만 Swift에서는 If문을 3항 연산자로 사용할 수 있다.그래서 아래와 같은 형태로도 제법 쓰고 있다.var isToday = \"2022-06-24\"let todayLabel.isHidden = isToday == \"2022-06-24\" ? false : true// todayLabel.isHidden은 false의 값을 가지게 되고, 화면에 드러나게 된다.메일보내기포스팅에 잘못된 부분이 있거나 궁금하신 점이 있다면, 왼쪽 사이드 하단 메뉴에서 로퍼즈팀으로 메일을 보내주세요!최대한 빠른 시간 내에 회신드릴게요! 감사합니다." }, { "title": "Segue로 화면 전환 하는 방법", "url": "/posts/moving-scene-with-segue/", "categories": "iOS, Guide", "tags": "ios, guide", "date": "2022-06-19 08:00:00 +0000", "snippet": "iOS앱은 화면과 화면을, 컨트롤러와 컨트롤러를 전환하는 방법이 꽤 쉽다. XCode IDE가 병맛인 것만 빼면 아주 간단하게 화면을 전환할 수 있다.이 페이지는 가장 기본적인 Segue를 이용한 화면전환 방법이다.스토리보드에서는 이렇게컨트롤러 배치ViewController를 2개 배치두 개의 ViewController를 배치한 후, Segue를 연결하는 방법은 2가지 있다. 특정 뷰에 직접 연결하거나 컨트롤러끼리 연결하는 방법이다. 상황에 따라 골라 쓰면 되겠다.Segue 연결, 첫번째 방법첫 번째 방법은, Button과 같은 View와 ViewController를 연결하는 것이다. 마우스 오른쪽 버튼을 클릭해서 메뉴를 호출, 드래그해서 연결한다.마우스 오른쪽 버튼을 눌러 연결혹은컨트롤(Ctrl) 키를 누른 상태에서 마우스로 드래그하면 된다.마우스 오른쪽 버튼을 눌러 Touch Up Inside와 같이 특별한 동작을 요구하지 않는 한 이 방법이 더 간결하다. 컨트롤(Ctrl) 키를 이용한 방법은 Button의 IBAction함수를 만들때에도 사용할 수 있다.컨트롤 키를 누른 상태에서 드래그로 연결그리고 손을 떼면 아래와 같은 Manual Segue를 볼 수 있는데,Manual Segue에서 등장 방식을 선택Show 또는 Preset Modally를 선택한다. 스마트폰 앱에서는 Show, Present Modally를 사용한다.Segue가 연결된 것을 확인이제 앱을 실행해보면 어떠한 코드도 작성하지 않았지만 해당 버튼을 눌렀을 때 화면이 전환되는 것을 볼 수 있다. 특정 View에 직접 Segue를 연결하는 이 방법은 별도의 @IBAction함수가 필요없다. Storyboard에서 각 Controller를 연결해주는 것만으로도 화면을 전환할 수 있기 때문이다. 화면 전환 기능을 하는 버튼이 2개 미만일 때 사용하는 것을 추천한다. 스토리보드가 수많은 Segue로 더러워지는 것이 싫다면 말이다.Segue 연결, 두번째 방법두 번째 방법은, ViewController와 ViewController를 연결하는 것이다. 첫번째 방법이 특정 View에만 Segue를 연결해서 해당 View로만 화면을 전환하도록 했다면, 이 방법으로는 약간의 코드가 필요하다. 하지만 모든 View에 화면을 전환할 수 있는 기능을 줄 수 있다.ViewController와 ViewController 연결3개의 ViewController를 더 추가해서 컨트롤(Ctrl) 키를 누른 상태로 드래그해서 각각의 뷰를 연결했다.ViewController와 ViewController끼리 연결된 모습.swift파일과 연결이제 각 ViewController와 .swift 파일을 연결해준다.각각 클래스를 만들어 연결Segue Identifier정의이렇게 연결된 상태에서 각각의 Segue Identifier를 준다.Segue Identifier 정의IBAction함수 만들기각 Button의 IBAction함수를 만들어 이벤트를 받는다.Button의 IBAction3개의 버튼 모두 IBAction함수를 만들었다면 아래와 같은 모습이 되어야 한다.Inspectors와 IBAction완성이 방법에서는 Storyboard에서 Class와 Segue Identifier를 정의 하는 등 조금 더 작업이 필요했다.이제 약간의 코드만 작성하면 완성이다.코드화면을 전환하는 코드는 단 한줄이다.performSegue(withIdentifier: \"Segue Identifier\", sender: self)물론, 이는 단순하게 화면만 전환하는 코드일 뿐이고, 데이터를 넘기는 등의 작업은 한 줄보다는 많은 코드를 작성해야 한다.이제 아까 정의해준 Segue Identifier를 파라미터로 각 Button의 IBAction에 작성한다.class ViewController: UIViewController { override func viewDidLoad() { ... } @IBAction func goThirdView(_ sender: UIButton) { performSegue(withIdentifier: \"ThirdView\", sender: self) } @IBAction func goFourthView(_ sender: UIButton) { performSegue(withIdentifier: \"FourthView\", sender: self) } @IBAction func goFifthView(_ sender: UIButton) { performSegue(withIdentifier: \"FifthView\", sender: self) } }이제 앱을 실행해보자. 이제 단 한줄의 Segue로 3개의 버튼 모두 각 ViewController를 띄울 것이다.메일보내기포스팅에 잘못된 부분이 있거나 궁금하신 점이 있다면, 왼쪽 사이드 하단 메뉴에서 로퍼즈팀으로 메일을 보내주세요!최대한 빠른 시간 내에 회신드릴게요! 감사합니다." }, { "title": "iOS앱 리스트 만드는 방법, TableView", "url": "/posts/table-view/", "categories": "iOS, Guide", "tags": "ios, guide", "date": "2022-06-18 05:46:00 +0000", "snippet": "모바일 앱에서 다량의 데이터를 직관적이고 간단하게 보여주는 대표적인 방법이 바로 리스트입니다. iOS앱에서는 이 리스트를 테이블 뷰 또는 컬렉션뷰라는 이름으로 제공하고 있는데요, 첫번째 테이블 뷰를 다뤄볼까 합니다. 테이블뷰는 기본적으로 셀(Cell) 타입 4종류를 지원하고, 커스터마이징한 셀로도 만들 수 있습니다.각설하고 바로 만들어 볼까요?스토리보드는 이렇게테이블 뷰테이블 뷰를 구현하는 방식은 2가지가 있어요. TableViewController를 스토리보드에 배치하는 것 ViewController안에 TableView를 배치하는 것첫 번째 방법은 TableViewController를 스토리보드에 배치하고 UITableViewController를 상속받은 파일을 연결하면, 구현에 필요한 위임이나 메소드를 Xcode에서 자동으로 코드를 만들어줍니다. 그래서 구현이 한결 편하죠. 하지만 컨트롤러 전체가 테이블 뷰를 위해 만들어 져 있기 때문에 다른 UI를 배치할 수 없다는 단점이 있습니다.두 번째 방법은 ViewController안에 UITableView를 배치하는 것입니다. 모든 로직을 직접 구현해야 하는 번거로움이 있지만 다른 UIView들과 조금 더 유연하게 화면을 만들 수 있다는 장점이 있어서 개인적으로 선호하는 더 선호하는 편이에요.물론, 상황에 맞게 구현하면 좋겠죠?아래와 같이 테이블 뷰를 스토리보드에 배치해주세요.ViewController안에 TableView를 배치테이블 뷰의 셀 기본 셀 타입 4종류기본적으로 Xcode에서 제공하는 셀 타입들 입니다. 아이폰의 기본 앱들에서 많이 보던 UI죠? 오른쪽 Attributes Inspector-Accessroy에서 지정할 수 있습니다. 하나씩 눌러보면 어떤 모습인지 스토리보드에서 바로 확인할 수 있으니 마음에 드는 걸 선택하시면 될 것 것네요.Xcode에서 기본으로 제공하는 Cell Type테이블뷰 셀의 Accessary 타입들 커스텀 셀XIB파일을 따로 만들어 셀을 커스터마이징할 수 있습니다.먼저 파일을 만들 때 Also Create XIB file을 체크해주시고요, TableViewCell을 상속받는 클래스를 만들면 아래와 같이 파일이 만들어지는 것을 볼 수 있어요. 이 XIB에 UILabel, UIButton등의 뷰를 배치해보세요. 나만의 멋진 커스텀 테이블 뷰를 만들 수 있습니다.커스터마이징 셀을 위한 XIB파일레이아웃을 정하고 서브뷰들을 배치했다면, XIB 파일에 클래스를 연결해줘야 합니다. Inspector에서 아래와 같이 클래스를 연결해주세요.XIB파일와 클래스파일 연결코드에서 이 XIB을 찾기 위해선 셀의 이름이 필요합니다. 역시 Inspector에서 설정할 수 있고요, Identifier를 작성해주세요. 이 Identifier가 XIB의 이름이 되는 것입니다.XIB파일에 아이디 만들어주기데이터 만들기디자인 패턴중 MVC패턴을 이용해서 만들어볼 생각이에요.각각 Model, View, Controller인데요, 프로젝트의 소스 코드 구조를 각각의 역할로 구분하고 그룹지어 유지보수나 가독성을 조금 더 향상할 수 있습니다.MVC패턴의 파일구조 DataModel은 데이터가 저장되는, 개발자가 만드는 임의의 자료형이며, DataManager는 DataModel과 ViewContorller사이에서 다리역할을 하며 데이터를 가공하고 컨트롤러에 뿌려줍니다.코딩DataModel과 DataManager DataModel struct DataModel { let age: Int let name: String} DataManager struct DataManager { var datas = [ DataModel(age: 19, name: \"JongSu\"), DataModel(age: 36, name: \"YunSeong\"), DataModel(age: 27, name: \"JiWoo\") ] func getUserData(idx: Int) -&gt; DataModel { return datas[idx] }} 확장(Extension)테이블뷰는 Delegate와 DataSource 등 프로토콜을 모두 필수로 위임받아 구현해야 합니다.하지만 그 전에, 구현하기에 앞서 확장(Extension)이라는 개념에 대해서 살짝 언급해볼까 합니다.스위프트 공식 홈페이지에 설명된 글을 한번 볼까요?Extensions add new functionality to an existing class, structure, enumeration, or protocol type. This includes the ability to extend types for which you don’t have access to the original source code (known as retroactive modeling). Extensions are similar to categories in Objective-C. (Unlike Objective-C categories, Swift extensions don’t have names.)확장 기능은 기존 클래스, 구조, 열거형 또는 프로토콜 유형에 새 기능을 추가하는 것이다. 이 기능은 원본 소스 코드에 액세스할 수 없는 유형을 확장하는 기능이 포함된다. 확장자는 Objective-C의 범주와 비슷하다. (Object-C와는 달리 Swift 확장자는 이름이 없습니다.)확장(Extension)을 위와 같이 정의하고 있는데, 간단히 이야기해서 이미 정의되어 있는 구조체 및 클래스등을 필요에 따라 확장해서 쓸 수 있다는 것입니다. 말만 봐서는 어떤 건지 와닿지 않으실 것 같은데요, 이미 만들어져 있는 함수를 개발자가 커스텀할 수 있음을 뜻한다고 생각하시면 편할 것 같아요.먼저 테이블 뷰의 delegate와 dataSource를 아래와 같이 self로 지정해주세요. 현재 컨트롤러에서 확장하겠다는 의미입니다.//MARK: - ViewDidLoad()class ViewController: UIViewContoller { . . . @IBOutlet weak var tableView: UITableView! override func viewDidLoad() { super.viewDidLoad() self.tableView.delegate = self self.tableView.dataSource = self }}아래와 같이 UITableViewDelegate구현에 필요한 함수들이 없다며 오류가 뜨는데요, 테이블 뷰를 확장(Extension)해서 구현해 줄게요.프로토콜 위임시 내용을 구현안했을 때그리고 확장하기 전에 하나만 더 해줄게요.위에서 만들어준 XIB 파일을 테이블뷰에 등록해주는 작업이 필요합니다. 아직 테이블 뷰는 개발자가 커스텀해서 만든 셀의 존재를 모르고 있거든요.override func viewDidLoad() { super.viewDidLoad() . . . //nimName은 클래스명, forCellReuseIdentifier는 셀의 identifier를 넣어준다. tableView.register(UINib(nibName: \"TableViewCell\", bundle: nil), forCellReuseIdentifier: \"TableViewCell\")}DataManager객체 선언과 Delegate와 DataSource 연결테이블 뷰에 데이터를 넣어 잘 나오는 지 확인해볼게요.먼저 컨트롤러는 DataManager로부터 데이터를 가져오기 때문에 객체를 만들어 주세요. 이 객체를 통해 셀에 데이터를 넣어주고 테이블 뷰에 뿌려줄 것입니다.class ViewController: UIViewContoller { private let dm = DataManager() . . .}데이터 소스(DataSource)UITableViewDataSource를 확장하게 되면 화면에 테이블 뷰를 어떻게 나타낼지 정할 수 있습니다. 몇개의 셀을 보여줄 것인지, 어떻게 보여줄 것인지 등을 말이죠.//MARK: - UITableViewDataSource, //셀을 얼마나, 어떻게 보여줘야 하는지를 구현한다.extension ViewController: UITableViewDataSource { func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int { //나타낼 셀의 갯수 return dm.datas.count // return dm.getDataCount() } func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell { //커스텀한 셀을 Identifier로 찾아서 가져와 데이터를 넣어준다. //만약 해당 Identifier로 셀을 찾지 못한다면 기본 타입인 TableViewCell()을 Return한다. guard let cell = tableView.dequeueReusableCell(withIdentifier: \"TableViewCell\") as? TableViewCell else { return TableViewCell() } let data = dm.datas[indexPath.item] cell.nameLabel.text = data.name cell.ageLabel.text = data.age.description + \"살\" // cell.setUpDataAtViews(data) return cell }}델리게이트(Delegate)delegate는 터치 이벤트등의 사용자 액션에 대한 응답을 구현하는 일이에요. 여러 메서드를 제공하지만 대게 셀을 선택했을 때와 옆으로 밀어 삭제하는 메서드를 주로 구현합니다.//MARK: - ViewController classclass ViewController { ... }//MARK: - UITableViewDelegate//셀을 터치하는 등의 이벤트 액션을 구현한다.extension ViewController: UITableViewDelegate { func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) { guard let cell = tableView.cellForRow(at: indexPath) else { return } //TO DO } }결과완성메일보내기포스팅에 잘못된 부분이 있거나 궁금하신 점이 있다면, 왼쪽 사이드 하단 메뉴에서 로퍼즈팀으로 메일을 보내주세요!최대한 빠른 시간 내에 회신드릴게요! 감사합니다." } ]
